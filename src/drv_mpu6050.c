/*
 * drv_mpu6050.c
 *
 *  Created on:
 *      Author: Katarzyna Stachyra <kas.stachyra@gmail.com>
 */
//#include "stm32f4xx_hal.h"
#include "stm32f4xx.h"
#include "stm32f4xx_gpio.h"

#include <FreeRTOS.h>
#include <task.h>
#include <queue.h>
#include <semphr.h>

#include <stdint.h>
#include <math.h>
#include <ctype.h>
#include <inttypes.h>
#include <stdio.h>

#include "serial.h"
#include "drv_mpu6050.h"
#include "drv_hmc5883l.h"
#include "i2c.h"
#include "delay_timer.h"

#define MPU6050_ADDRESS         0x68


#define DMP_MEM_START_ADDR 0x6E
#define DMP_MEM_R_W 0x6F

#define INV_MAX_NUM_ACCEL_SAMPLES      (8)
#define DMP_REF_QUATERNION             (0)
#define DMP_REF_GYROS                  (DMP_REF_QUATERNION + 4) // 4
#define DMP_REF_CONTROL                (DMP_REF_GYROS + 3)      // 7
#define DMP_REF_RAW                    (DMP_REF_CONTROL + 4)    // 11
#define DMP_REF_RAW_EXTERNAL           (DMP_REF_RAW + 8)        // 19
#define DMP_REF_ACCEL                  (DMP_REF_RAW_EXTERNAL + 6)       // 25
#define DMP_REF_QUANT_ACCEL            (DMP_REF_ACCEL + 3)      // 28
#define DMP_REF_QUATERNION_6AXIS       (DMP_REF_QUANT_ACCEL + INV_MAX_NUM_ACCEL_SAMPLES)        // 36
#define DMP_REF_EIS                    (DMP_REF_QUATERNION_6AXIS + 4)   // 40
#define DMP_REF_DMP_PACKET             (DMP_REF_EIS + 3)        // 43
#define DMP_REF_GARBAGE                (DMP_REF_DMP_PACKET + 1) // 44
#define DMP_REF_LAST                   (DMP_REF_GARBAGE + 1)    // 45

#define MPU_RA_XG_OFFS_TC       0x00    //[7] PWR_MODE, [6:1] XG_OFFS_TC, [0] OTP_BNK_VLD
#define MPU_RA_YG_OFFS_TC       0x01    //[7] PWR_MODE, [6:1] YG_OFFS_TC, [0] OTP_BNK_VLD
#define MPU_RA_ZG_OFFS_TC       0x02    //[7] PWR_MODE, [6:1] ZG_OFFS_TC, [0] OTP_BNK_VLD
#define MPU_RA_X_FINE_GAIN      0x03    //[7:0] X_FINE_GAIN
#define MPU_RA_Y_FINE_GAIN      0x04    //[7:0] Y_FINE_GAIN
#define MPU_RA_Z_FINE_GAIN      0x05    //[7:0] Z_FINE_GAIN
#define MPU_RA_XA_OFFS_H        0x06    //[15:0] XA_OFFS
#define MPU_RA_XA_OFFS_L_TC     0x07
#define MPU_RA_YA_OFFS_H        0x08    //[15:0] YA_OFFS
#define MPU_RA_YA_OFFS_L_TC     0x09
#define MPU_RA_ZA_OFFS_H        0x0A    //[15:0] ZA_OFFS
#define MPU_RA_ZA_OFFS_L_TC     0x0B
#define MPU_RA_PRODUCT_ID       0x0C    // Product ID Register
#define MPU_RA_XG_OFFS_USRH     0x13    //[15:0] XG_OFFS_USR
#define MPU_RA_XG_OFFS_USRL     0x14
#define MPU_RA_YG_OFFS_USRH     0x15    //[15:0] YG_OFFS_USR
#define MPU_RA_YG_OFFS_USRL     0x16
#define MPU_RA_ZG_OFFS_USRH     0x17    //[15:0] ZG_OFFS_USR
#define MPU_RA_ZG_OFFS_USRL     0x18
#define MPU_RA_SMPLRT_DIV       0x19
#define MPU_RA_CONFIG           0x1A
#define MPU_RA_GYRO_CONFIG      0x1B
#define MPU_RA_ACCEL_CONFIG     0x1C
#define MPU_RA_FF_THR           0x1D
#define MPU_RA_FF_DUR           0x1E
#define MPU_RA_MOT_THR          0x1F
#define MPU_RA_MOT_DUR          0x20
#define MPU_RA_ZRMOT_THR        0x21
#define MPU_RA_ZRMOT_DUR        0x22
#define MPU_RA_FIFO_EN          0x23
#define MPU_RA_I2C_MST_CTRL     0x24
#define MPU_RA_I2C_SLV0_ADDR    0x25
#define MPU_RA_I2C_SLV0_REG     0x26
#define MPU_RA_I2C_SLV0_CTRL    0x27
#define MPU_RA_I2C_SLV1_ADDR    0x28
#define MPU_RA_I2C_SLV1_REG     0x29
#define MPU_RA_I2C_SLV1_CTRL    0x2A
#define MPU_RA_I2C_SLV2_ADDR    0x2B
#define MPU_RA_I2C_SLV2_REG     0x2C
#define MPU_RA_I2C_SLV2_CTRL    0x2D
#define MPU_RA_I2C_SLV3_ADDR    0x2E
#define MPU_RA_I2C_SLV3_REG     0x2F
#define MPU_RA_I2C_SLV3_CTRL    0x30
#define MPU_RA_I2C_SLV4_ADDR    0x31
#define MPU_RA_I2C_SLV4_REG     0x32
#define MPU_RA_I2C_SLV4_DO      0x33
#define MPU_RA_I2C_SLV4_CTRL    0x34
#define MPU_RA_I2C_SLV4_DI      0x35
#define MPU_RA_I2C_MST_STATUS   0x36
#define MPU_RA_INT_PIN_CFG      0x37
#define MPU_RA_INT_ENABLE       0x38
#define MPU_RA_DMP_INT_STATUS   0x39
#define MPU_RA_INT_STATUS       0x3A
#define MPU_RA_ACCEL_XOUT_H     0x3B
#define MPU_RA_ACCEL_XOUT_L     0x3C
#define MPU_RA_ACCEL_YOUT_H     0x3D
#define MPU_RA_ACCEL_YOUT_L     0x3E
#define MPU_RA_ACCEL_ZOUT_H     0x3F
#define MPU_RA_ACCEL_ZOUT_L     0x40
#define MPU_RA_TEMP_OUT_H       0x41
#define MPU_RA_TEMP_OUT_L       0x42
#define MPU_RA_GYRO_XOUT_H      0x43
#define MPU_RA_GYRO_XOUT_L      0x44
#define MPU_RA_GYRO_YOUT_H      0x45
#define MPU_RA_GYRO_YOUT_L      0x46
#define MPU_RA_GYRO_ZOUT_H      0x47
#define MPU_RA_GYRO_ZOUT_L      0x48
#define MPU_RA_EXT_SENS_DATA_00 0x49
#define MPU_RA_MOT_DETECT_STATUS    0x61
#define MPU_RA_I2C_SLV0_DO      0x63
#define MPU_RA_I2C_SLV1_DO      0x64
#define MPU_RA_I2C_SLV2_DO      0x65
#define MPU_RA_I2C_SLV3_DO      0x66
#define MPU_RA_I2C_MST_DELAY_CTRL   0x67
#define MPU_RA_SIGNAL_PATH_RESET    0x68
#define MPU_RA_MOT_DETECT_CTRL      0x69
#define MPU_RA_USER_CTRL        0x6A
#define MPU_RA_PWR_MGMT_1       0x6B
#define MPU_RA_PWR_MGMT_2       0x6C
#define MPU_RA_BANK_SEL         0x6D
#define MPU_RA_MEM_START_ADDR   0x6E
#define MPU_RA_MEM_R_W          0x6F
#define MPU_RA_DMP_CFG_1        0x70
#define MPU_RA_DMP_CFG_2        0x71
#define MPU_RA_FIFO_COUNTH      0x72
#define MPU_RA_FIFO_COUNTL      0x73
#define MPU_RA_FIFO_R_W         0x74
#define MPU_RA_WHO_AM_I         0x75

#define MPU6050_SMPLRT_DIV      0       //8000Hz

#define MPU6050_LPF_256HZ       0
#define MPU6050_LPF_188HZ       1
#define MPU6050_LPF_98HZ        2
#define MPU6050_LPF_42HZ        3
#define MPU6050_LPF_20HZ        4
#define MPU6050_LPF_10HZ        5
#define MPU6050_LPF_5HZ         6

#define MPU6050_DMP_CODE_SIZE 			1962
#define MPU6050_DMP_CONFIG_SIZE 		232
#define MPU6050_DMP_UPDATES_SIZE 		140
#define MPU6050_DMP_dmpPacketSize 		42


#define MPU6050_DMP_CODE_SIZE_6 		1929 // dmpMemory[]
#define MPU6050_DMP_CONFIG_SIZE_6 		192 // dmpConfig[]
#define MPU6050_DMP_UPDATES_SIZE_6 		47 // dmpUpdates[]

#define MPU6050_DMP_MEMORY_BANKS        8
#define MPU6050_DMP_MEMORY_BANK_SIZE    256
#define MPU6050_DMP_MEMORY_CHUNK_SIZE   16

#define MPU6050_CLOCK_INTERNAL          0x00
#define MPU6050_CLOCK_PLL_XGYRO         0x01
#define MPU6050_CLOCK_PLL_YGYRO         0x02
#define MPU6050_CLOCK_PLL_ZGYRO         0x03
#define MPU6050_CLOCK_PLL_EXT32K        0x04
#define MPU6050_CLOCK_PLL_EXT19M        0x05
#define MPU6050_CLOCK_KEEP_RESET        0x07

#define MPU_I2C_SLV_RW_BIT 7
#define MPU_I2C_SLV_ADDR_BIT 6
#define MPU_I2C_SLV_ADDR_LENGTH 7
#define MPU_I2C_SLV_EN_BIT 7
#define MPU_I2C_SLV_BYTE_SW_BIT 6
#define MPU_I2C_SLV_REG_DIS_BIT 5
#define MPU_I2C_SLV_GRP_BIT 4
#define MPU_I2C_SLV_LEN_BIT 3
#define MPU_I2C_SLV_LEN_LENGTH 4

///> Size of imu queue (in bytes)
//#define IMU_QUEUE_SIZE   1024//64
//xQueueHandle imu_queue;
xSemaphoreHandle imu_data_rdy, imu_data_update;
static void imu_task(void *parameters);
angles imu_position;

uint8_t buffer[14];
uint16_t dmpPacketSize;
uint8_t *dmpPacketBuffer;

float actualThreshold;
bool useCalibrate;
axis dg;
axis tg;
axis th;

float dpsPerDigit, rangePerDigit;

uint8_t mpu6050_dmpInitialize(void);
void mpu6050_dmpEnable(void);
void mpu6050_dmpDisable(void);

void mpu6050_getQuaternion(const uint8_t* packet, quaternion *quat);
void mpu6050_getYawPitchRoll(quaternion *quat, angles *angle, axis *gravity);
void mpu6050_setMemoryBank(uint8_t bank, uint8_t prefetchEnabled, uint8_t userBank);
void mpu6050_setMemoryStartAddress(uint8_t address);
void mpu6050_readMemoryBlock(uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address);
uint8_t mpu6050_writeMemoryBlock(const uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address);
uint8_t mpu6050_writeDMPConfigurationSet(const uint8_t *data, uint16_t dataSize);
uint16_t mpu6050_getFIFOCount(void);
void mpu6050_getFIFOBytes(uint8_t *data, uint8_t length);
uint8_t mpu6050_getIntStatus(void);
void mpu6050_resetFIFO(void);
int8_t mpu6050_getXGyroOffsetTC(void);
void mpu6050_setXGyroOffsetTC(int8_t offset);
int8_t mpu6050_getYGyroOffsetTC(void);
void mpu6050_setYGyroOffsetTC(int8_t offset);
int8_t mpu6050_getZGyroOffsetTC(void);
void mpu6050_setZGyroOffsetTC(int8_t offset);
void mpu6050_setSleepDisabled(void);
void mpu6050_setSleepEnabled(void);


bool sensorsAutodetect(void)
{
    if(mpu6050Detect()){
    	mpu6050_reset();//
    	mpu6050_setClockSource(0x01); //MPU6050_CLOCK_PLL_XGYRO
    	mpu6050GyroInit(MPU6050_SCALE_250DPS);
    	mpu6050AccInit(MPU6050_RANGE_2G);
    	mpu6050_setSleepDisabled();
    	serial_puts("init\r\n");
    	return true;
    }
  return false;
}


bool mpu6050Detect(void)
{
	// Reset calibrate values
	dg.x = 0;
	dg.y = 0;
	dg.z = 0;
	useCalibrate = false;
	// Reset threshold values
	tg.x = 0;
	tg.y = 0;
	tg.z = 0;
	actualThreshold = 0;

    bool ack;
    uint8_t sig;

    delay_ms(35);        // datasheet page 13 says 30ms

    ack = i2cRead(MPU6050_ADDRESS, MPU_RA_WHO_AM_I, 1, &sig);
    if (!ack)
        return false;

    // So like, MPU6xxx has a "WHO_AM_I" register, that is used to verify the identity of the device.
    // The contents of WHO_AM_I are the upper 6 bits of the MPU-60X0s 7-bit I2C address.
    // The least significant bit of the MPU-60X0s I2C address is determined by the value of the AD0 pin.
    if (sig != (MPU6050_ADDRESS & 0x7e))
        return false;

    // determine product ID and accel revision
    //i2cRead(MPU6050_ADDRESS, MPU_RA_XA_OFFS_H, 6, tmp);
    //rev = ((tmp[5] & 0x01) << 2) | ((tmp[3] & 0x01) << 1) | (tmp[1] & 0x01);

    return true;
}

void mpu6050AccInit(mpu6050_range_t range)
{
	 switch (range)
	{
		case MPU6050_RANGE_2G:
			rangePerDigit = .000061f;
			break;
		case MPU6050_RANGE_4G:
			rangePerDigit = .000122f;
			break;
		case MPU6050_RANGE_8G:
			rangePerDigit = .000244f;
			break;
		case MPU6050_RANGE_16G:
			rangePerDigit = .0004882f;
			break;
		default:
			break;
	}
	i2cWrite(MPU6050_ADDRESS, MPU_RA_ACCEL_CONFIG, range << 3);
}

void mpu6050AccRead(int16_t *accData)
{
    uint8_t buf[6];

    if(i2cRead(MPU6050_ADDRESS, MPU_RA_ACCEL_XOUT_H, 6, buf))
    {
		accData[0] = (int16_t)((buf[0] << 8) | buf[1]);// / 8;
		accData[1] = (int16_t)((buf[2] << 8) | buf[3]);// / 8;
		accData[2] = (int16_t)((buf[4] << 8) | buf[5]);// / 8;
    }
}

void mpu6050AccReadScaled(int16_t *accData)
{
    mpu6050AccRead(accData);
	accData[0] = accData[0] * rangePerDigit;
	accData[1] = accData[1] * rangePerDigit;
	accData[2] = accData[2] * rangePerDigit;
}

void mpu6050AccReadNormalized(int16_t *accData)
{
    mpu6050AccRead(accData);
	accData[0] = accData[0] * rangePerDigit * 9.80665f;
	accData[1] = accData[1] * rangePerDigit * 9.80665f;
	accData[2] = accData[2] * rangePerDigit * 9.80665f;
}


void mpu6050GyroInit(mpu6050_dps_t scale)
{
	 switch (scale)
	{
		case MPU6050_SCALE_250DPS:
			dpsPerDigit = .007633f;
			break;
		case MPU6050_SCALE_500DPS:
			dpsPerDigit = .015267f;
			break;
		case MPU6050_SCALE_1000DPS:
			dpsPerDigit = .030487f;
			break;
		case MPU6050_SCALE_2000DPS:
			dpsPerDigit = .060975f;
			break;
		default:
			break;
	}
    i2cWrite(MPU6050_ADDRESS, MPU_RA_GYRO_CONFIG, scale << 3);

}

void mpu6050GyroRead(int16_t * gyroData)
{
    uint8_t buf[6];
    i2cRead(MPU6050_ADDRESS, MPU_RA_GYRO_XOUT_H, 6, buf);
    gyroData[0] = (int16_t)((buf[0] << 8) | buf[1]);// / 4;
    gyroData[1] = (int16_t)((buf[2] << 8) | buf[3]);// / 4;
    gyroData[2] = (int16_t)((buf[4] << 8) | buf[5]);// / 4;

}

void mpu6050GyroReadScaled(int16_t * gyroData)
{
	mpu6050GyroRead(gyroData);
	gyroData[0] = gyroData[0] * dpsPerDigit;
	gyroData[1] = gyroData[1] * dpsPerDigit;
	gyroData[2] = gyroData[2] * dpsPerDigit;

}

void mpu6050GyroCalibrate(int16_t * gyroData, uint8_t samples)
{
	// Set calibrate
	useCalibrate = true;
	// Reset values
	float sumX = 0;
	float sumY = 0;
	float sumZ = 0;
	float sigmaX = 0;
	float sigmaY = 0;
	float sigmaZ = 0;
	// Read n-samples
	for (uint8_t i = 0; i < samples; ++i)
	{
		mpu6050GyroRead(gyroData);
		sumX += gyroData[0];
		sumY += gyroData[1];
		sumZ += gyroData[2];

		sigmaX += gyroData[0] * gyroData[0];
		sigmaY += gyroData[1] * gyroData[1];
		sigmaZ += gyroData[2] * gyroData[2];
		delay_ms(5);
	}
	// Calculate delta vectors
	dg.x = sumX / samples;
	dg.y = sumY / samples;
	dg.z = sumZ / samples;

}


void mpu6050GyroReadNormalized(int16_t * gyroData)
{
	mpu6050GyroRead(gyroData);
	if (useCalibrate)
	{
		gyroData[0] = (gyroData[0] - dg.x) * dpsPerDigit;
		gyroData[1] = (gyroData[1]- dg.y) * dpsPerDigit;
		gyroData[2] = (gyroData[2]- dg.z) * dpsPerDigit;
	} else
	{
		gyroData[0] = gyroData[0] * dpsPerDigit;
		gyroData[1] = gyroData[1] * dpsPerDigit;
		gyroData[2] = gyroData[2] * dpsPerDigit;
	}
	if (actualThreshold)
	{
		if (abs(gyroData[0]) < tg.x) gyroData[0] = 0;
		if (abs(gyroData[1]) < tg.y) gyroData[1] = 0;
		if (abs(gyroData[2]) < tg.z) gyroData[2] = 0;
	}
}

void mpu6050GyroDetThreshold(int16_t * gyroData, uint8_t samples, uint8_t multiple)
{
	if (multiple > 0)
	{
		// If not calibrated, need calibrate
		if (!useCalibrate)
		{
			mpu6050GyroCalibrate(gyroData, samples);
		}
		// Calculate threshold vectors
		tg.x = th.z * multiple;
		tg.y= th.y * multiple;
		tg.z = th.z * multiple;
	} else
	{
		// No threshold
		tg.x = 0;
		tg.y = 0;
		tg.z = 0;
	}
	// Remember old threshold value
	actualThreshold = multiple;
}

//9axis
/* ================================================================================================ *
| Default MotionApps v4.1 48-byte FIFO packet structure: |
| |
| [QUAT W][ ][QUAT X][ ][QUAT Y][ ][QUAT Z][ ][GYRO X][ ][GYRO Y][ ] |
|     0 1  2     3 4  5     6 7  8     9 10 11  12 13  14  15 16  17 18 19 20 21 22 23 |
| |
| [GYRO Z][ ][MAG X ][MAG Y ][MAG Z ][ACC X ][ ][ACC Y ][ ][ACC Z ][ ][ ] |
| 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 |
* ================================================================================================ */

// this block of memory gets written to the MPU on start-up, and it seems
// to be volatile memory, so it has to be done each time (it only takes ~1
// second though)
const unsigned char mpu6050_dmpMemory[MPU6050_DMP_CODE_SIZE] = {
		 // bank 0, 256 bytes
		0xFB, 0x00, 0x00, 0x3E, 0x00, 0x0B, 0x00, 0x36, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00,
		0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0xFA, 0x80, 0x00, 0x0B, 0x12, 0x82, 0x00, 0x01,
		0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x28, 0x00, 0x00, 0xFF, 0xFF, 0x45, 0x81, 0xFF, 0xFF, 0xFA, 0x72, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x03, 0xE8, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x7F, 0xFF, 0xFF, 0xFE, 0x80, 0x01,
		0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x3E, 0x03, 0x30, 0x40, 0x00, 0x00, 0x00, 0x02, 0xCA, 0xE3, 0x09, 0x3E, 0x80, 0x00, 0x00,
		0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
		0x41, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x2A, 0x00, 0x00, 0x16, 0x55, 0x00, 0x00, 0x21, 0x82,
		0xFD, 0x87, 0x26, 0x50, 0xFD, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x05, 0x80, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
		0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x6F, 0x00, 0x02, 0x65, 0x32, 0x00, 0x00, 0x5E, 0xC0,
		0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xFB, 0x8C, 0x6F, 0x5D, 0xFD, 0x5D, 0x08, 0xD9, 0x00, 0x7C, 0x73, 0x3B, 0x00, 0x6C, 0x12, 0xCC,
		0x32, 0x00, 0x13, 0x9D, 0x32, 0x00, 0xD0, 0xD6, 0x32, 0x00, 0x08, 0x00, 0x40, 0x00, 0x01, 0xF4,
		0xFF, 0xE6, 0x80, 0x79, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0xD6, 0x00, 0x00, 0x27, 0x10,
		// bank 1, 256 bytes
		0xFB, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
		0x00, 0x00, 0xFA, 0x36, 0xFF, 0xBC, 0x30, 0x8E, 0x00, 0x05, 0xFB, 0xF0, 0xFF, 0xD9, 0x5B, 0xC8,
		0xFF, 0xD0, 0x9A, 0xBE, 0x00, 0x00, 0x10, 0xA9, 0xFF, 0xF4, 0x1E, 0xB2, 0x00, 0xCE, 0xBB, 0xF7,
		0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x02, 0x00, 0x00, 0x0C,
		0xFF, 0xC2, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0xCF, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x14,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x03, 0x3F, 0x68, 0xB6, 0x79, 0x35, 0x28, 0xBC, 0xC6, 0x7E, 0xD1, 0x6C,
		0x80, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB2, 0x6A, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x30,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x25, 0x4D, 0x00, 0x2F, 0x70, 0x6D, 0x00, 0x00, 0x05, 0xAE, 0x00, 0x0C, 0x02, 0xD0,
		// bank 2, 256 bytes
		0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x01, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0xFF, 0xEF, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
		0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x78, 0xA2,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		// bank 3, 256 bytes
		0xD8, 0xDC, 0xF4, 0xD8, 0xB9, 0xAB, 0xF3, 0xF8, 0xFA, 0xF1, 0xBA, 0xA2, 0xDE, 0xB2, 0xB8, 0xB4,
		0xA8, 0x81, 0x98, 0xF7, 0x4A, 0x90, 0x7F, 0x91, 0x6A, 0xF3, 0xF9, 0xDB, 0xA8, 0xF9, 0xB0, 0xBA,
		0xA0, 0x80, 0xF2, 0xCE, 0x81, 0xF3, 0xC2, 0xF1, 0xC1, 0xF2, 0xC3, 0xF3, 0xCC, 0xA2, 0xB2, 0x80,
		0xF1, 0xC6, 0xD8, 0x80, 0xBA, 0xA7, 0xDF, 0xDF, 0xDF, 0xF2, 0xA7, 0xC3, 0xCB, 0xC5, 0xB6, 0xF0,
		0x87, 0xA2, 0x94, 0x24, 0x48, 0x70, 0x3C, 0x95, 0x40, 0x68, 0x34, 0x58, 0x9B, 0x78, 0xA2, 0xF1,
		0x83, 0x92, 0x2D, 0x55, 0x7D, 0xD8, 0xB1, 0xB4, 0xB8, 0xA1, 0xD0, 0x91, 0x80, 0xF2, 0x70, 0xF3,
		0x70, 0xF2, 0x7C, 0x80, 0xA8, 0xF1, 0x01, 0xB0, 0x98, 0x87, 0xD9, 0x43, 0xD8, 0x86, 0xC9, 0x88,
		0xBA, 0xA1, 0xF2, 0x0E, 0xB8, 0x97, 0x80, 0xF1, 0xA9, 0xDF, 0xDF, 0xDF, 0xAA, 0xDF, 0xDF, 0xDF,
		0xF2, 0xAA, 0xC5, 0xCD, 0xC7, 0xA9, 0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97, 0x97, 0xF1, 0xA9, 0x89,
		0x26, 0x46, 0x66, 0xB0, 0xB4, 0xBA, 0x80, 0xAC, 0xDE, 0xF2, 0xCA, 0xF1, 0xB2, 0x8C, 0x02, 0xA9,
		0xB6, 0x98, 0x00, 0x89, 0x0E, 0x16, 0x1E, 0xB8, 0xA9, 0xB4, 0x99, 0x2C, 0x54, 0x7C, 0xB0, 0x8A,
		0xA8, 0x96, 0x36, 0x56, 0x76, 0xF1, 0xB9, 0xAF, 0xB4, 0xB0, 0x83, 0xC0, 0xB8, 0xA8, 0x97, 0x11,
		0xB1, 0x8F, 0x98, 0xB9, 0xAF, 0xF0, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xF1, 0xA3, 0x29, 0x55,
		0x7D, 0xAF, 0x83, 0xB5, 0x93, 0xF0, 0x00, 0x28, 0x50, 0xF5, 0xBA, 0xAD, 0x8F, 0x9F, 0x28, 0x54,
		0x7C, 0xB9, 0xF1, 0xA3, 0x86, 0x9F, 0x61, 0xA6, 0xDA, 0xDE, 0xDF, 0xDB, 0xB2, 0xB6, 0x8E, 0x9D,
		0xAE, 0xF5, 0x60, 0x68, 0x70, 0xB1, 0xB5, 0xF1, 0xDA, 0xA6, 0xDF, 0xD9, 0xA6, 0xFA, 0xA3, 0x86,
		// bank 4, 256 bytes
		0x96, 0xDB, 0x31, 0xA6, 0xD9, 0xF8, 0xDF, 0xBA, 0xA6, 0x8F, 0xC2, 0xC5, 0xC7, 0xB2, 0x8C, 0xC1,
		0xB8, 0xA2, 0xDF, 0xDF, 0xDF, 0xA3, 0xDF, 0xDF, 0xDF, 0xD8, 0xD8, 0xF1, 0xB8, 0xA8, 0xB2, 0x86,
		0xB4, 0x98, 0x0D, 0x35, 0x5D, 0xB8, 0xAA, 0x98, 0xB0, 0x87, 0x2D, 0x35, 0x3D, 0xB2, 0xB6, 0xBA,
		0xAF, 0x8C, 0x96, 0x19, 0x8F, 0x9F, 0xA7, 0x0E, 0x16, 0x1E, 0xB4, 0x9A, 0xB8, 0xAA, 0x87, 0x2C,
		0x54, 0x7C, 0xB9, 0xA3, 0xDE, 0xDF, 0xDF, 0xA3, 0xB1, 0x80, 0xF2, 0xC4, 0xCD, 0xC9, 0xF1, 0xB8,
		0xA9, 0xB4, 0x99, 0x83, 0x0D, 0x35, 0x5D, 0x89, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0xB5, 0x93, 0xA3,
		0x0E, 0x16, 0x1E, 0xA9, 0x2C, 0x54, 0x7C, 0xB8, 0xB4, 0xB0, 0xF1, 0x97, 0x83, 0xA8, 0x11, 0x84,
		0xA5, 0x09, 0x98, 0xA3, 0x83, 0xF0, 0xDA, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xD8, 0xF1, 0xA5,
		0x29, 0x55, 0x7D, 0xA5, 0x85, 0x95, 0x02, 0x1A, 0x2E, 0x3A, 0x56, 0x5A, 0x40, 0x48, 0xF9, 0xF3,
		0xA3, 0xD9, 0xF8, 0xF0, 0x98, 0x83, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0x97, 0x82, 0xA8, 0xF1,
		0x11, 0xF0, 0x98, 0xA2, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xDA, 0xF3, 0xDE, 0xD8, 0x83, 0xA5,
		0x94, 0x01, 0xD9, 0xA3, 0x02, 0xF1, 0xA2, 0xC3, 0xC5, 0xC7, 0xD8, 0xF1, 0x84, 0x92, 0xA2, 0x4D,
		0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
		0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0x93, 0xA3, 0x4D,
		0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
		0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0xA8, 0x8A, 0x9A,
		// bank 5, 256 bytes
		0xF0, 0x28, 0x50, 0x78, 0x9E, 0xF3, 0x88, 0x18, 0xF1, 0x9F, 0x1D, 0x98, 0xA8, 0xD9, 0x08, 0xD8,
		0xC8, 0x9F, 0x12, 0x9E, 0xF3, 0x15, 0xA8, 0xDA, 0x12, 0x10, 0xD8, 0xF1, 0xAF, 0xC8, 0x97, 0x87,
		0x34, 0xB5, 0xB9, 0x94, 0xA4, 0x21, 0xF3, 0xD9, 0x22, 0xD8, 0xF2, 0x2D, 0xF3, 0xD9, 0x2A, 0xD8,
		0xF2, 0x35, 0xF3, 0xD9, 0x32, 0xD8, 0x81, 0xA4, 0x60, 0x60, 0x61, 0xD9, 0x61, 0xD8, 0x6C, 0x68,
		0x69, 0xD9, 0x69, 0xD8, 0x74, 0x70, 0x71, 0xD9, 0x71, 0xD8, 0xB1, 0xA3, 0x84, 0x19, 0x3D, 0x5D,
		0xA3, 0x83, 0x1A, 0x3E, 0x5E, 0x93, 0x10, 0x30, 0x81, 0x10, 0x11, 0xB8, 0xB0, 0xAF, 0x8F, 0x94,
		0xF2, 0xDA, 0x3E, 0xD8, 0xB4, 0x9A, 0xA8, 0x87, 0x29, 0xDA, 0xF8, 0xD8, 0x87, 0x9A, 0x35, 0xDA,
		0xF8, 0xD8, 0x87, 0x9A, 0x3D, 0xDA, 0xF8, 0xD8, 0xB1, 0xB9, 0xA4, 0x98, 0x85, 0x02, 0x2E, 0x56,
		0xA5, 0x81, 0x00, 0x0C, 0x14, 0xA3, 0x97, 0xB0, 0x8A, 0xF1, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9,
		0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x84, 0x0D, 0xDA, 0x0E, 0xD8, 0xA3, 0x29, 0x83, 0xDA,
		0x2C, 0x0E, 0xD8, 0xA3, 0x84, 0x49, 0x83, 0xDA, 0x2C, 0x4C, 0x0E, 0xD8, 0xB8, 0xB0, 0x97, 0x86,
		0xA8, 0x31, 0x9B, 0x06, 0x99, 0x07, 0xAB, 0x97, 0x28, 0x88, 0x9B, 0xF0, 0x0C, 0x20, 0x14, 0x40,
		0xB9, 0xA3, 0x8A, 0xC3, 0xC5, 0xC7, 0x9A, 0xA3, 0x28, 0x50, 0x78, 0xF1, 0xB5, 0x93, 0x01, 0xD9,
		0xDF, 0xDF, 0xDF, 0xD8, 0xB8, 0xB4, 0xA8, 0x8C, 0x9C, 0xF0, 0x04, 0x28, 0x51, 0x79, 0x1D, 0x30,
		0x14, 0x38, 0xB2, 0x82, 0xAB, 0xD0, 0x98, 0x2C, 0x50, 0x50, 0x78, 0x78, 0x9B, 0xF1, 0x1A, 0xB0,
		0xF0, 0xB1, 0x83, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0xB0, 0x8B, 0x29, 0x51, 0x79, 0xB1, 0x83, 0x24,
		// bank 6, 256 bytes
		0x70, 0x59, 0xB0, 0x8B, 0x20, 0x58, 0x71, 0xB1, 0x83, 0x44, 0x69, 0x38, 0xB0, 0x8B, 0x39, 0x40,
		0x68, 0xB1, 0x83, 0x64, 0x48, 0x31, 0xB0, 0x8B, 0x30, 0x49, 0x60, 0xA5, 0x88, 0x20, 0x09, 0x71,
		0x58, 0x44, 0x68, 0x11, 0x39, 0x64, 0x49, 0x30, 0x19, 0xF1, 0xAC, 0x00, 0x2C, 0x54, 0x7C, 0xF0,
		0x8C, 0xA8, 0x04, 0x28, 0x50, 0x78, 0xF1, 0x88, 0x97, 0x26, 0xA8, 0x59, 0x98, 0xAC, 0x8C, 0x02,
		0x26, 0x46, 0x66, 0xF0, 0x89, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38,
		0x64, 0x48, 0x31, 0xA9, 0x88, 0x09, 0x20, 0x59, 0x70, 0xAB, 0x11, 0x38, 0x40, 0x69, 0xA8, 0x19,
		0x31, 0x48, 0x60, 0x8C, 0xA8, 0x3C, 0x41, 0x5C, 0x20, 0x7C, 0x00, 0xF1, 0x87, 0x98, 0x19, 0x86,
		0xA8, 0x6E, 0x76, 0x7E, 0xA9, 0x99, 0x88, 0x2D, 0x55, 0x7D, 0x9E, 0xB9, 0xA3, 0x8A, 0x22, 0x8A,
		0x6E, 0x8A, 0x56, 0x8A, 0x5E, 0x9F, 0xB1, 0x83, 0x06, 0x26, 0x46, 0x66, 0x0E, 0x2E, 0x4E, 0x6E,
		0x9D, 0xB8, 0xAD, 0x00, 0x2C, 0x54, 0x7C, 0xF2, 0xB1, 0x8C, 0xB4, 0x99, 0xB9, 0xA3, 0x2D, 0x55,
		0x7D, 0x81, 0x91, 0xAC, 0x38, 0xAD, 0x3A, 0xB5, 0x83, 0x91, 0xAC, 0x2D, 0xD9, 0x28, 0xD8, 0x4D,
		0xD9, 0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0x8C, 0x9D, 0xAE, 0x29, 0xD9, 0x04, 0xAE, 0xD8, 0x51,
		0xD9, 0x04, 0xAE, 0xD8, 0x79, 0xD9, 0x04, 0xD8, 0x81, 0xF3, 0x9D, 0xAD, 0x00, 0x8D, 0xAE, 0x19,
		0x81, 0xAD, 0xD9, 0x01, 0xD8, 0xF2, 0xAE, 0xDA, 0x26, 0xD8, 0x8E, 0x91, 0x29, 0x83, 0xA7, 0xD9,
		0xAD, 0xAD, 0xAD, 0xAD, 0xF3, 0x2A, 0xD8, 0xD8, 0xF1, 0xB0, 0xAC, 0x89, 0x91, 0x3E, 0x5E, 0x76,
		0xF3, 0xAC, 0x2E, 0x2E, 0xF1, 0xB1, 0x8C, 0x5A, 0x9C, 0xAC, 0x2C, 0x28, 0x28, 0x28, 0x9C, 0xAC,
		// bank 7, 170 bytes (remainder)
		0x30, 0x18, 0xA8, 0x98, 0x81, 0x28, 0x34, 0x3C, 0x97, 0x24, 0xA7, 0x28, 0x34, 0x3C, 0x9C, 0x24,
		0xF2, 0xB0, 0x89, 0xAC, 0x91, 0x2C, 0x4C, 0x6C, 0x8A, 0x9B, 0x2D, 0xD9, 0xD8, 0xD8, 0x51, 0xD9,
		0xD8, 0xD8, 0x79, 0xD9, 0xD8, 0xD8, 0xF1, 0x9E, 0x88, 0xA3, 0x31, 0xDA, 0xD8, 0xD8, 0x91, 0x2D,
		0xD9, 0x28, 0xD8, 0x4D, 0xD9, 0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x83, 0x93, 0x35, 0x3D,
		0x80, 0x25, 0xDA, 0xD8, 0xD8, 0x85, 0x69, 0xDA, 0xD8, 0xD8, 0xB4, 0x93, 0x81, 0xA3, 0x28, 0x34,
		0x3C, 0xF3, 0xAB, 0x8B, 0xA3, 0x91, 0xB6, 0x09, 0xB4, 0xD9, 0xAB, 0xDE, 0xB0, 0x87, 0x9C, 0xB9,
		0xA3, 0xDD, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x95, 0xF1, 0xA3, 0xA3, 0xA3, 0x9D, 0xF1, 0xA3, 0xA3,
		0xA3, 0xA3, 0xF2, 0xA3, 0xB4, 0x90, 0x80, 0xF2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
		0xA3, 0xA3, 0xB2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xB0, 0x87, 0xB5, 0x99, 0xF1, 0xA3, 0xA3,
		0xA3, 0x98, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x97, 0xA3, 0xA3, 0xA3, 0xA3, 0xF3, 0x9B, 0xA3, 0xA3,
		0xDC, 0xB9, 0xA7, 0xF1, 0x26, 0x26, 0x26, 0xD8, 0xD8, 0xFF
};

const unsigned char mpu6050_dmpConfig[MPU6050_DMP_CONFIG_SIZE] = {
		// BANK OFFSET LENGTH [DATA]
		0x02, 0xEC, 0x04, 0x00, 0x47, 0x7D, 0x1A, // ?
		0x03, 0x82, 0x03, 0x4C, 0xCD, 0x6C, // FCFG_1 inv_set_gyro_calibration
		0x03, 0xB2, 0x03, 0x36, 0x56, 0x76, // FCFG_3 inv_set_gyro_calibration
		0x00, 0x68, 0x04, 0x02, 0xCA, 0xE3, 0x09, // D_0_104 inv_set_gyro_calibration
		0x01, 0x0C, 0x04, 0x00, 0x00, 0x00, 0x00, // D_1_152 inv_set_accel_calibration
		0x03, 0x86, 0x03, 0x0C, 0xC9, 0x2C, // FCFG_2 inv_set_accel_calibration
		0x03, 0x90, 0x03, 0x26, 0x46, 0x66, // (continued)...FCFG_2 inv_set_accel_calibration
		0x00, 0x6C, 0x02, 0x40, 0x00, // D_0_108 inv_set_accel_calibration
		0x02, 0x40, 0x04, 0x00, 0x00, 0x00, 0x00, // CPASS_MTX_00 inv_set_compass_calibration
		0x02, 0x44, 0x04, 0x40, 0x00, 0x00, 0x00, // CPASS_MTX_01
		0x02, 0x48, 0x04, 0x00, 0x00, 0x00, 0x00, // CPASS_MTX_02
		0x02, 0x4C, 0x04, 0x40, 0x00, 0x00, 0x00, // CPASS_MTX_10
		0x02, 0x50, 0x04, 0x00, 0x00, 0x00, 0x00, // CPASS_MTX_11
		0x02, 0x54, 0x04, 0x00, 0x00, 0x00, 0x00, // CPASS_MTX_12
		0x02, 0x58, 0x04, 0x00, 0x00, 0x00, 0x00, // CPASS_MTX_20
		0x02, 0x5C, 0x04, 0x00, 0x00, 0x00, 0x00, // CPASS_MTX_21
		0x02, 0xBC, 0x04, 0xC0, 0x00, 0x00, 0x00, // CPASS_MTX_22
		0x01, 0xEC, 0x04, 0x00, 0x00, 0x40, 0x00, // D_1_236 inv_apply_endian_accel
		0x03, 0x86, 0x06, 0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97, // FCFG_2 inv_set_mpu_sensors
		0x04, 0x22, 0x03, 0x0D, 0x35, 0x5D, // CFG_MOTION_BIAS inv_turn_on_bias_from_no_motion
		0x00, 0xA3, 0x01, 0x00, // ?
		0x04, 0x29, 0x04, 0x87, 0x2D, 0x35, 0x3D, // FCFG_5 inv_set_bias_update
		0x07, 0x62, 0x05, 0xF1, 0x20, 0x28, 0x30, 0x38, // CFG_8 inv_send_quaternion
		0x07, 0x9F, 0x01, 0x30, // CFG_16 inv_set_footer
		0x07, 0x67, 0x01, 0x9A, // CFG_GYRO_SOURCE inv_send_gyro
		0x07, 0x68, 0x04, 0xF1, 0x28, 0x30, 0x38, // CFG_9 inv_send_gyro -> inv_construct3_fifo
		0x07, 0x62, 0x05, 0xF1, 0x20, 0x28, 0x30, 0x38, // ?
		0x02, 0x0C, 0x04, 0x00, 0x00, 0x00, 0x00, // ?
		0x07, 0x83, 0x06, 0xC2, 0xCA, 0xC4, 0xA3, 0xA3, 0xA3, // ?
		// SPECIAL 0x01 = enable interrupts
		0x00, 0x00, 0x00, 0x01, // SET INT_ENABLE, SPECIAL INSTRUCTION
		0x07, 0xA7, 0x01, 0xFE, // ?
		0x07, 0x62, 0x05, 0xF1, 0x20, 0x28, 0x30, 0x38, // ?
		0x07, 0x67, 0x01, 0x9A, // ?
		0x07, 0x68, 0x04, 0xF1, 0x28, 0x30, 0x38, // CFG_12 inv_send_accel -> inv_construct3_fifo
		0x07, 0x8D, 0x04, 0xF1, 0x28, 0x30, 0x38, // ??? CFG_12 inv_send_mag -> inv_construct3_fifo
		0x02, 0x16, 0x02, 0x00, 0x01 // D_0_22 inv_set_fifo_rate
		// This very last 0x01 WAS a 0x09, which drops the FIFO rate down to 20 Hz. 0x07 is 25 Hz,
		// 0x01 is 100Hz. Going faster than 100Hz (0x00=200Hz) tends to result in very noisy data.
		// DMP output frequency is calculated easily using this equation: (200Hz / (1 + value))
		// It is important to make sure the host processor can keep up with reading and processing
		// the FIFO output at the desired rate. Handling FIFO overflow cleanly is also a good idea.
};

const unsigned char mpu6050_dmpUpdates[MPU6050_DMP_UPDATES_SIZE] = {
		 0x01, 0xB2, 0x02, 0xFF, 0xF5,
		0x01, 0x90, 0x04, 0x0A, 0x0D, 0x97, 0xC0,
		0x00, 0xA3, 0x01, 0x00,
		0x04, 0x29, 0x04, 0x87, 0x2D, 0x35, 0x3D,
		0x01, 0x6A, 0x02, 0x06, 0x00,
		0x01, 0x60, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x60, 0x04, 0x40, 0x00, 0x00, 0x00,
		0x02, 0x60, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x01, 0x08, 0x02, 0x01, 0x20,
		0x01, 0x0A, 0x02, 0x00, 0x4E,
		0x01, 0x02, 0x02, 0xFE, 0xB3,
		0x02, 0x6C, 0x04, 0x00, 0x00, 0x00, 0x00, // READ
		0x02, 0x6C, 0x04, 0xFA, 0xFE, 0x00, 0x00,
		0x02, 0x60, 0x0C, 0xFF, 0xFF, 0xCB, 0x4D, 0x00, 0x01, 0x08, 0xC1, 0xFF, 0xFF, 0xBC, 0x2C,
		0x02, 0xF4, 0x04, 0x00, 0x00, 0x00, 0x00,
		0x02, 0xF8, 0x04, 0x00, 0x00, 0x00, 0x00,
		0x02, 0xFC, 0x04, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x60, 0x04, 0x40, 0x00, 0x00, 0x00,
		0x00, 0x60, 0x04, 0x00, 0x40, 0x00, 0x00
};

//6 axis
/* ================================================================================================ *
| Default MotionApps v2.0 42-byte FIFO packet structure: |
| |
| [QUAT W][ ][QUAT X][ ][QUAT Y][ ][QUAT Z][ ][GYRO X][ ][GYRO Y][ ] |
| 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 |
| |
| [GYRO Z][ ][ACC X ][ ][ACC Y ][ ][ACC Z ][ ][ ] |
| 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 |
* ================================================================================================ */
// this block of memory gets written to the MPU on start-up, and it seems
// to be volatile memory, so it has to be done each time (it only takes ~1
// second though)
const unsigned char mpu6050_dmpMemory6[MPU6050_DMP_CODE_SIZE_6] = {
	// bank 0, 256 bytes
	0xFB, 0x00, 0x00, 0x3E, 0x00, 0x0B, 0x00, 0x36, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00,
	0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0xFA, 0x80, 0x00, 0x0B, 0x12, 0x82, 0x00, 0x01,
	0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x28, 0x00, 0x00, 0xFF, 0xFF, 0x45, 0x81, 0xFF, 0xFF, 0xFA, 0x72, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x03, 0xE8, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x7F, 0xFF, 0xFF, 0xFE, 0x80, 0x01,
	0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x3E, 0x03, 0x30, 0x40, 0x00, 0x00, 0x00, 0x02, 0xCA, 0xE3, 0x09, 0x3E, 0x80, 0x00, 0x00,
	0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
	0x41, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x2A, 0x00, 0x00, 0x16, 0x55, 0x00, 0x00, 0x21, 0x82,
	0xFD, 0x87, 0x26, 0x50, 0xFD, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x05, 0x80, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x6F, 0x00, 0x02, 0x65, 0x32, 0x00, 0x00, 0x5E, 0xC0,
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFB, 0x8C, 0x6F, 0x5D, 0xFD, 0x5D, 0x08, 0xD9, 0x00, 0x7C, 0x73, 0x3B, 0x00, 0x6C, 0x12, 0xCC,
	0x32, 0x00, 0x13, 0x9D, 0x32, 0x00, 0xD0, 0xD6, 0x32, 0x00, 0x08, 0x00, 0x40, 0x00, 0x01, 0xF4,
	0xFF, 0xE6, 0x80, 0x79, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0xD6, 0x00, 0x00, 0x27, 0x10,
	// bank 1, 256 bytes
	0xFB, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xFA, 0x36, 0xFF, 0xBC, 0x30, 0x8E, 0x00, 0x05, 0xFB, 0xF0, 0xFF, 0xD9, 0x5B, 0xC8,
	0xFF, 0xD0, 0x9A, 0xBE, 0x00, 0x00, 0x10, 0xA9, 0xFF, 0xF4, 0x1E, 0xB2, 0x00, 0xCE, 0xBB, 0xF7,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x02, 0x00, 0x00, 0x0C,
	0xFF, 0xC2, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0xCF, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x14,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x03, 0x3F, 0x68, 0xB6, 0x79, 0x35, 0x28, 0xBC, 0xC6, 0x7E, 0xD1, 0x6C,
	0x80, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB2, 0x6A, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x30,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x25, 0x4D, 0x00, 0x2F, 0x70, 0x6D, 0x00, 0x00, 0x05, 0xAE, 0x00, 0x0C, 0x02, 0xD0,
	// bank 2, 256 bytes
	0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0xFF, 0xEF, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
	0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	// bank 3, 256 bytes
	0xD8, 0xDC, 0xBA, 0xA2, 0xF1, 0xDE, 0xB2, 0xB8, 0xB4, 0xA8, 0x81, 0x91, 0xF7, 0x4A, 0x90, 0x7F,
	0x91, 0x6A, 0xF3, 0xF9, 0xDB, 0xA8, 0xF9, 0xB0, 0xBA, 0xA0, 0x80, 0xF2, 0xCE, 0x81, 0xF3, 0xC2,
	0xF1, 0xC1, 0xF2, 0xC3, 0xF3, 0xCC, 0xA2, 0xB2, 0x80, 0xF1, 0xC6, 0xD8, 0x80, 0xBA, 0xA7, 0xDF,
	0xDF, 0xDF, 0xF2, 0xA7, 0xC3, 0xCB, 0xC5, 0xB6, 0xF0, 0x87, 0xA2, 0x94, 0x24, 0x48, 0x70, 0x3C,
	0x95, 0x40, 0x68, 0x34, 0x58, 0x9B, 0x78, 0xA2, 0xF1, 0x83, 0x92, 0x2D, 0x55, 0x7D, 0xD8, 0xB1,
	0xB4, 0xB8, 0xA1, 0xD0, 0x91, 0x80, 0xF2, 0x70, 0xF3, 0x70, 0xF2, 0x7C, 0x80, 0xA8, 0xF1, 0x01,
	0xB0, 0x98, 0x87, 0xD9, 0x43, 0xD8, 0x86, 0xC9, 0x88, 0xBA, 0xA1, 0xF2, 0x0E, 0xB8, 0x97, 0x80,
	0xF1, 0xA9, 0xDF, 0xDF, 0xDF, 0xAA, 0xDF, 0xDF, 0xDF, 0xF2, 0xAA, 0xC5, 0xCD, 0xC7, 0xA9, 0x0C,
	0xC9, 0x2C, 0x97, 0x97, 0x97, 0x97, 0xF1, 0xA9, 0x89, 0x26, 0x46, 0x66, 0xB0, 0xB4, 0xBA, 0x80,
	0xAC, 0xDE, 0xF2, 0xCA, 0xF1, 0xB2, 0x8C, 0x02, 0xA9, 0xB6, 0x98, 0x00, 0x89, 0x0E, 0x16, 0x1E,
	0xB8, 0xA9, 0xB4, 0x99, 0x2C, 0x54, 0x7C, 0xB0, 0x8A, 0xA8, 0x96, 0x36, 0x56, 0x76, 0xF1, 0xB9,
	0xAF, 0xB4, 0xB0, 0x83, 0xC0, 0xB8, 0xA8, 0x97, 0x11, 0xB1, 0x8F, 0x98, 0xB9, 0xAF, 0xF0, 0x24,
	0x08, 0x44, 0x10, 0x64, 0x18, 0xF1, 0xA3, 0x29, 0x55, 0x7D, 0xAF, 0x83, 0xB5, 0x93, 0xAF, 0xF0,
	0x00, 0x28, 0x50, 0xF1, 0xA3, 0x86, 0x9F, 0x61, 0xA6, 0xDA, 0xDE, 0xDF, 0xD9, 0xFA, 0xA3, 0x86,
	0x96, 0xDB, 0x31, 0xA6, 0xD9, 0xF8, 0xDF, 0xBA, 0xA6, 0x8F, 0xC2, 0xC5, 0xC7, 0xB2, 0x8C, 0xC1,
	0xB8, 0xA2, 0xDF, 0xDF, 0xDF, 0xA3, 0xDF, 0xDF, 0xDF, 0xD8, 0xD8, 0xF1, 0xB8, 0xA8, 0xB2, 0x86,
	// bank 4, 256 bytes
	0xB4, 0x98, 0x0D, 0x35, 0x5D, 0xB8, 0xAA, 0x98, 0xB0, 0x87, 0x2D, 0x35, 0x3D, 0xB2, 0xB6, 0xBA,
	0xAF, 0x8C, 0x96, 0x19, 0x8F, 0x9F, 0xA7, 0x0E, 0x16, 0x1E, 0xB4, 0x9A, 0xB8, 0xAA, 0x87, 0x2C,
	0x54, 0x7C, 0xB9, 0xA3, 0xDE, 0xDF, 0xDF, 0xA3, 0xB1, 0x80, 0xF2, 0xC4, 0xCD, 0xC9, 0xF1, 0xB8,
	0xA9, 0xB4, 0x99, 0x83, 0x0D, 0x35, 0x5D, 0x89, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0xB5, 0x93, 0xA3,
	0x0E, 0x16, 0x1E, 0xA9, 0x2C, 0x54, 0x7C, 0xB8, 0xB4, 0xB0, 0xF1, 0x97, 0x83, 0xA8, 0x11, 0x84,
	0xA5, 0x09, 0x98, 0xA3, 0x83, 0xF0, 0xDA, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xD8, 0xF1, 0xA5,
	0x29, 0x55, 0x7D, 0xA5, 0x85, 0x95, 0x02, 0x1A, 0x2E, 0x3A, 0x56, 0x5A, 0x40, 0x48, 0xF9, 0xF3,
	0xA3, 0xD9, 0xF8, 0xF0, 0x98, 0x83, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0x97, 0x82, 0xA8, 0xF1,
	0x11, 0xF0, 0x98, 0xA2, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xDA, 0xF3, 0xDE, 0xD8, 0x83, 0xA5,
	0x94, 0x01, 0xD9, 0xA3, 0x02, 0xF1, 0xA2, 0xC3, 0xC5, 0xC7, 0xD8, 0xF1, 0x84, 0x92, 0xA2, 0x4D,
	0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
	0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0x93, 0xA3, 0x4D,
	0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
	0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0xA8, 0x8A, 0x9A,
	0xF0, 0x28, 0x50, 0x78, 0x9E, 0xF3, 0x88, 0x18, 0xF1, 0x9F, 0x1D, 0x98, 0xA8, 0xD9, 0x08, 0xD8,
	0xC8, 0x9F, 0x12, 0x9E, 0xF3, 0x15, 0xA8, 0xDA, 0x12, 0x10, 0xD8, 0xF1, 0xAF, 0xC8, 0x97, 0x87,
	// bank 5, 256 bytes
	0x34, 0xB5, 0xB9, 0x94, 0xA4, 0x21, 0xF3, 0xD9, 0x22, 0xD8, 0xF2, 0x2D, 0xF3, 0xD9, 0x2A, 0xD8,
	0xF2, 0x35, 0xF3, 0xD9, 0x32, 0xD8, 0x81, 0xA4, 0x60, 0x60, 0x61, 0xD9, 0x61, 0xD8, 0x6C, 0x68,
	0x69, 0xD9, 0x69, 0xD8, 0x74, 0x70, 0x71, 0xD9, 0x71, 0xD8, 0xB1, 0xA3, 0x84, 0x19, 0x3D, 0x5D,
	0xA3, 0x83, 0x1A, 0x3E, 0x5E, 0x93, 0x10, 0x30, 0x81, 0x10, 0x11, 0xB8, 0xB0, 0xAF, 0x8F, 0x94,
	0xF2, 0xDA, 0x3E, 0xD8, 0xB4, 0x9A, 0xA8, 0x87, 0x29, 0xDA, 0xF8, 0xD8, 0x87, 0x9A, 0x35, 0xDA,
	0xF8, 0xD8, 0x87, 0x9A, 0x3D, 0xDA, 0xF8, 0xD8, 0xB1, 0xB9, 0xA4, 0x98, 0x85, 0x02, 0x2E, 0x56,
	0xA5, 0x81, 0x00, 0x0C, 0x14, 0xA3, 0x97, 0xB0, 0x8A, 0xF1, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9,
	0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x84, 0x0D, 0xDA, 0x0E, 0xD8, 0xA3, 0x29, 0x83, 0xDA,
	0x2C, 0x0E, 0xD8, 0xA3, 0x84, 0x49, 0x83, 0xDA, 0x2C, 0x4C, 0x0E, 0xD8, 0xB8, 0xB0, 0xA8, 0x8A,
	0x9A, 0xF5, 0x20, 0xAA, 0xDA, 0xDF, 0xD8, 0xA8, 0x40, 0xAA, 0xD0, 0xDA, 0xDE, 0xD8, 0xA8, 0x60,
	0xAA, 0xDA, 0xD0, 0xDF, 0xD8, 0xF1, 0x97, 0x86, 0xA8, 0x31, 0x9B, 0x06, 0x99, 0x07, 0xAB, 0x97,
	0x28, 0x88, 0x9B, 0xF0, 0x0C, 0x20, 0x14, 0x40, 0xB8, 0xB0, 0xB4, 0xA8, 0x8C, 0x9C, 0xF0, 0x04,
	0x28, 0x51, 0x79, 0x1D, 0x30, 0x14, 0x38, 0xB2, 0x82, 0xAB, 0xD0, 0x98, 0x2C, 0x50, 0x50, 0x78,
	0x78, 0x9B, 0xF1, 0x1A, 0xB0, 0xF0, 0x8A, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x8B, 0x29, 0x51, 0x79,
	0x8A, 0x24, 0x70, 0x59, 0x8B, 0x20, 0x58, 0x71, 0x8A, 0x44, 0x69, 0x38, 0x8B, 0x39, 0x40, 0x68,
	0x8A, 0x64, 0x48, 0x31, 0x8B, 0x30, 0x49, 0x60, 0xA5, 0x88, 0x20, 0x09, 0x71, 0x58, 0x44, 0x68,
	// bank 6, 256 bytes
	0x11, 0x39, 0x64, 0x49, 0x30, 0x19, 0xF1, 0xAC, 0x00, 0x2C, 0x54, 0x7C, 0xF0, 0x8C, 0xA8, 0x04,
	0x28, 0x50, 0x78, 0xF1, 0x88, 0x97, 0x26, 0xA8, 0x59, 0x98, 0xAC, 0x8C, 0x02, 0x26, 0x46, 0x66,
	0xF0, 0x89, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38, 0x64, 0x48, 0x31,
	0xA9, 0x88, 0x09, 0x20, 0x59, 0x70, 0xAB, 0x11, 0x38, 0x40, 0x69, 0xA8, 0x19, 0x31, 0x48, 0x60,
	0x8C, 0xA8, 0x3C, 0x41, 0x5C, 0x20, 0x7C, 0x00, 0xF1, 0x87, 0x98, 0x19, 0x86, 0xA8, 0x6E, 0x76,
	0x7E, 0xA9, 0x99, 0x88, 0x2D, 0x55, 0x7D, 0x9E, 0xB9, 0xA3, 0x8A, 0x22, 0x8A, 0x6E, 0x8A, 0x56,
	0x8A, 0x5E, 0x9F, 0xB1, 0x83, 0x06, 0x26, 0x46, 0x66, 0x0E, 0x2E, 0x4E, 0x6E, 0x9D, 0xB8, 0xAD,
	0x00, 0x2C, 0x54, 0x7C, 0xF2, 0xB1, 0x8C, 0xB4, 0x99, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0x81, 0x91,
	0xAC, 0x38, 0xAD, 0x3A, 0xB5, 0x83, 0x91, 0xAC, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9, 0x48, 0xD8,
	0x6D, 0xD9, 0x68, 0xD8, 0x8C, 0x9D, 0xAE, 0x29, 0xD9, 0x04, 0xAE, 0xD8, 0x51, 0xD9, 0x04, 0xAE,
	0xD8, 0x79, 0xD9, 0x04, 0xD8, 0x81, 0xF3, 0x9D, 0xAD, 0x00, 0x8D, 0xAE, 0x19, 0x81, 0xAD, 0xD9,
	0x01, 0xD8, 0xF2, 0xAE, 0xDA, 0x26, 0xD8, 0x8E, 0x91, 0x29, 0x83, 0xA7, 0xD9, 0xAD, 0xAD, 0xAD,
	0xAD, 0xF3, 0x2A, 0xD8, 0xD8, 0xF1, 0xB0, 0xAC, 0x89, 0x91, 0x3E, 0x5E, 0x76, 0xF3, 0xAC, 0x2E,
	0x2E, 0xF1, 0xB1, 0x8C, 0x5A, 0x9C, 0xAC, 0x2C, 0x28, 0x28, 0x28, 0x9C, 0xAC, 0x30, 0x18, 0xA8,
	0x98, 0x81, 0x28, 0x34, 0x3C, 0x97, 0x24, 0xA7, 0x28, 0x34, 0x3C, 0x9C, 0x24, 0xF2, 0xB0, 0x89,
	0xAC, 0x91, 0x2C, 0x4C, 0x6C, 0x8A, 0x9B, 0x2D, 0xD9, 0xD8, 0xD8, 0x51, 0xD9, 0xD8, 0xD8, 0x79,
	// bank 7, 138 bytes (remainder)
	0xD9, 0xD8, 0xD8, 0xF1, 0x9E, 0x88, 0xA3, 0x31, 0xDA, 0xD8, 0xD8, 0x91, 0x2D, 0xD9, 0x28, 0xD8,
	0x4D, 0xD9, 0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x83, 0x93, 0x35, 0x3D, 0x80, 0x25, 0xDA,
	0xD8, 0xD8, 0x85, 0x69, 0xDA, 0xD8, 0xD8, 0xB4, 0x93, 0x81, 0xA3, 0x28, 0x34, 0x3C, 0xF3, 0xAB,
	0x8B, 0xF8, 0xA3, 0x91, 0xB6, 0x09, 0xB4, 0xD9, 0xAB, 0xDE, 0xFA, 0xB0, 0x87, 0x9C, 0xB9, 0xA3,
	0xDD, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x95, 0xF1, 0xA3, 0xA3, 0xA3, 0x9D, 0xF1, 0xA3, 0xA3, 0xA3,
	0xA3, 0xF2, 0xA3, 0xB4, 0x90, 0x80, 0xF2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
	0xA3, 0xB2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xB0, 0x87, 0xB5, 0x99, 0xF1, 0xA3, 0xA3, 0xA3,
	0x98, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x97, 0xA3, 0xA3, 0xA3, 0xA3, 0xF3, 0x9B, 0xA3, 0xA3, 0xDC,
	0xB9, 0xA7, 0xF1, 0x26, 0x26, 0x26, 0xD8, 0xD8, 0xFF
};

const unsigned char mpu6050_dmpConfig6[MPU6050_DMP_CONFIG_SIZE_6] = {
	// BANK OFFSET LENGTH [DATA]
	0x03, 0x7B, 0x03, 0x4C, 0xCD, 0x6C, // FCFG_1 inv_set_gyro_calibration
	0x03, 0xAB, 0x03, 0x36, 0x56, 0x76, // FCFG_3 inv_set_gyro_calibration
	0x00, 0x68, 0x04, 0x02, 0xCB, 0x47, 0xA2, // D_0_104 inv_set_gyro_calibration
	0x02, 0x18, 0x04, 0x00, 0x05, 0x8B, 0xC1, // D_0_24 inv_set_gyro_calibration
	0x01, 0x0C, 0x04, 0x00, 0x00, 0x00, 0x00, // D_1_152 inv_set_accel_calibration
	0x03, 0x7F, 0x06, 0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97, // FCFG_2 inv_set_accel_calibration
	0x03, 0x89, 0x03, 0x26, 0x46, 0x66, // FCFG_7 inv_set_accel_calibration
	0x00, 0x6C, 0x02, 0x20, 0x00, // D_0_108 inv_set_accel_calibration
	0x02, 0x40, 0x04, 0x00, 0x00, 0x00, 0x00, // CPASS_MTX_00 inv_set_compass_calibration
	0x02, 0x44, 0x04, 0x00, 0x00, 0x00, 0x00, // CPASS_MTX_01
	0x02, 0x48, 0x04, 0x00, 0x00, 0x00, 0x00, // CPASS_MTX_02
	0x02, 0x4C, 0x04, 0x00, 0x00, 0x00, 0x00, // CPASS_MTX_10
	0x02, 0x50, 0x04, 0x00, 0x00, 0x00, 0x00, // CPASS_MTX_11
	0x02, 0x54, 0x04, 0x00, 0x00, 0x00, 0x00, // CPASS_MTX_12
	0x02, 0x58, 0x04, 0x00, 0x00, 0x00, 0x00, // CPASS_MTX_20
	0x02, 0x5C, 0x04, 0x00, 0x00, 0x00, 0x00, // CPASS_MTX_21
	0x02, 0xBC, 0x04, 0x00, 0x00, 0x00, 0x00, // CPASS_MTX_22
	0x01, 0xEC, 0x04, 0x00, 0x00, 0x40, 0x00, // D_1_236 inv_apply_endian_accel
	0x03, 0x7F, 0x06, 0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97, // FCFG_2 inv_set_mpu_sensors
	0x04, 0x02, 0x03, 0x0D, 0x35, 0x5D, // CFG_MOTION_BIAS inv_turn_on_bias_from_no_motion
	0x04, 0x09, 0x04, 0x87, 0x2D, 0x35, 0x3D, // FCFG_5 inv_set_bias_update
	0x00, 0xA3, 0x01, 0x00, // D_0_163 inv_set_dead_zone
	// SPECIAL 0x01 = enable interrupts
	0x00, 0x00, 0x00, 0x01, // SET INT_ENABLE at i=22, SPECIAL INSTRUCTION
	0x07, 0x86, 0x01, 0xFE, // CFG_6 inv_set_fifo_interupt
	0x07, 0x41, 0x05, 0xF1, 0x20, 0x28, 0x30, 0x38, // CFG_8 inv_send_quaternion
	0x07, 0x7E, 0x01, 0x30, // CFG_16 inv_set_footer
	0x07, 0x46, 0x01, 0x9A, // CFG_GYRO_SOURCE inv_send_gyro
	0x07, 0x47, 0x04, 0xF1, 0x28, 0x30, 0x38, // CFG_9 inv_send_gyro -> inv_construct3_fifo
	0x07, 0x6C, 0x04, 0xF1, 0x28, 0x30, 0x38, // CFG_12 inv_send_accel -> inv_construct3_fifo
	0x02, 0x16, 0x02, 0x00, 0x01 //0x01 // D_0_22 inv_set_fifo_rate
	// This very last 0x01 WAS a 0x09, which drops the FIFO rate down to 20 Hz. 0x07 is 25 Hz,
	// 0x01 is 100Hz. Going faster than 100Hz (0x00=200Hz) tends to result in very noisy data.
	// DMP output frequency is calculated easily using this equation: (200Hz / (1 + value))
	// It is important to make sure the host processor can keep up with reading and processing
	// the FIFO output at the desired rate. Handling FIFO overflow cleanly is also a good idea.
};
const unsigned char mpu6050_dmpUpdates6[MPU6050_DMP_UPDATES_SIZE_6] = {
	0x01, 0xB2, 0x02, 0xFF, 0xFF,
	0x01, 0x90, 0x04, 0x09, 0x23, 0xA1, 0x35,
	0x01, 0x6A, 0x02, 0x06, 0x00,
	0x01, 0x60, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x60, 0x04, 0x40, 0x00, 0x00, 0x00,
	0x01, 0x62, 0x02, 0x00, 0x00,
	0x00, 0x60, 0x04, 0x00, 0x40, 0x00, 0x00
};


/*
 * initialize mpu6050 dmp
 */
uint8_t mpu6050_dmpInitialize(void)
{
	mpu6050_reset();
	delay_ms(30);
    mpu6050_setSleepDisabled();

    mpu6050_setMemoryBank(0x10, 1, 1);
    mpu6050_setMemoryStartAddress(0x06);
    uint8_t hwRevision;
    i2cRead(MPU6050_ADDRESS, MPU_RA_MEM_R_W,1, &hwRevision);

    mpu6050_setMemoryBank(0, 0, 0);

    int8_t xgOffset = mpu6050_getXGyroOffset();
    int8_t ygOffset = mpu6050_getYGyroOffset();
    int8_t zgOffset = mpu6050_getZGyroOffset();

    mpu6050_setI2CMasterModeEnabled(0);
    mpu6050_setI2CBypassEnabled(1);

    HMC5883L_initialize();
    i2cWrite(0x1E, HMC5883L_RA_MODE, HMC5883L_MODE_CONTINUOUS << (HMC5883L_MODEREG_BIT - HMC5883L_MODEREG_LENGTH + 1));
    mpu6050_setI2CBypassEnabled(0);

    // X axis word
    mpu6050_setSlaveAddress(0, HMC5883L_DEFAULT_ADDRESS | 0x80);
    // 0x80 turns 7th bit ON, according to datasheet, 7th bit controls Read/Write direction
    mpu6050_setSlaveRegister(0, HMC5883L_RA_DATAX_H);
    mpu6050_setSlaveControl(0, true, false, false, false, 2); // num, slave_enabled, word_byte_swap, write_mode, group_offset, data_length
    // implemented prev method to set whole SLV*_CTRL reg at once.

    // Y axis word
    mpu6050_setSlaveAddress(1, HMC5883L_DEFAULT_ADDRESS | 0x80);
    mpu6050_setSlaveRegister(1, HMC5883L_RA_DATAY_H);
    mpu6050_setSlaveControl(1, true, false, false, false, 2);

    // Z axis word
    mpu6050_setSlaveAddress(2, HMC5883L_DEFAULT_ADDRESS | 0x80);
    mpu6050_setSlaveRegister(2, HMC5883L_RA_DATAZ_H);
    mpu6050_setSlaveControl(2, true, false, false, false, 2);

   mpu6050_setI2CMasterModeEnabled(1);

    //load DMP code into memory banks
    if (mpu6050_writeMemoryBlock(mpu6050_dmpMemory, MPU6050_DMP_CODE_SIZE, 0, 0) == 1) {
        if (mpu6050_writeDMPConfigurationSet(mpu6050_dmpConfig, MPU6050_DMP_CONFIG_SIZE)) {

        	//set clock source
        	i2cWriteBits(MPU6050_ADDRESS, MPU_RA_PWR_MGMT_1, 2, 3, MPU6050_CLOCK_PLL_ZGYRO);

        	//set DMP and FIFO_OFLOW interrupts enabled
        	i2cWrite(MPU6050_ADDRESS, MPU_RA_INT_ENABLE, 0x12);

            //set sample rate
        	i2cWrite(MPU6050_ADDRESS, MPU_RA_SMPLRT_DIV, 4); // 1khz / (1 + 4) = 200 Hz

            //set external frame sync to TEMP_OUT_L[0]
        	i2cWriteBits(MPU6050_ADDRESS, MPU_RA_CONFIG, 5, 3, 0x1);

            //set DLPF bandwidth to 42Hz
        	i2cWriteBits(MPU6050_ADDRESS, MPU_RA_CONFIG, 2, 3, 0x03);

            //set gyro sensitivity to +/- 2000 deg/sec
        	i2cWriteBits(MPU6050_ADDRESS, MPU_RA_GYRO_CONFIG, 4, 2, 0x03);

            //set DMP configuration bytes (function unknown)
            i2cWrite(MPU6050_ADDRESS,MPU_RA_DMP_CFG_1, 0x03);
            i2cWrite(MPU6050_ADDRESS, MPU_RA_DMP_CFG_2, 0x00);

            //clear OTP Bank flag
            i2cWriteBit(MPU6050_ADDRESS, MPU_RA_XG_OFFS_TC, 0, 0);

            //set X/Y/Z gyro offsets to previous values
            mpu6050_setXGyroOffsetTC(xgOffset);
            mpu6050_setYGyroOffsetTC(ygOffset);
            mpu6050_setZGyroOffsetTC(zgOffset);

            //writing final memory update 1/19 (function unknown)
            uint8_t dmpUpdate[16], j;
            uint16_t pos = 0;
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = mpu6050_dmpUpdates[pos];
            mpu6050_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);

            //writing final memory update 2/19 (function unknown)
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = mpu6050_dmpUpdates[pos];
            mpu6050_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);

            //reset FIFO
            i2cWriteBits(MPU6050_ADDRESS, MPU_RA_USER_CTRL, 2, 1, 1);

            //reading FIFO count
            uint8_t fifoCount = mpu6050_getFIFOCount();
            uint8_t fifoBuffer[128];

            //writing final memory update 3/19 (function unknown)
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = mpu6050_dmpUpdates[pos];
            mpu6050_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);

            //writing final memory update 4/19 (function unknown)
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = mpu6050_dmpUpdates[pos];
            mpu6050_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);

            //"Disabling all standby flags..."
           i2cWrite(MPU6050_ADDRESS, MPU_RA_PWR_MGMT_2, 0x00);
           //"Setting accelerometer sensitivity to +/- 2g..."
           i2cWrite(MPU6050_ADDRESS, MPU_RA_ACCEL_CONFIG, 0x00);

            //setting motion detection threshold to 2
            i2cWrite(MPU6050_ADDRESS, MPU_RA_MOT_THR, 2);

            //setting zero-motion detection threshold to 156
            i2cWrite(MPU6050_ADDRESS, MPU_RA_ZRMOT_THR, 156);

            //setting motion detection duration to 80
            i2cWrite(MPU6050_ADDRESS, MPU_RA_MOT_DUR, 80);

            //setting zero-motion detection duration to 0
            i2cWrite(MPU6050_ADDRESS, MPU_RA_ZRMOT_DUR, 0);

            // enable I2C master mode and reset DMP/FIFO
          //"Enabling I2C master mode..."
           i2cWrite(MPU6050_ADDRESS, MPU_RA_USER_CTRL, 0x20);

           //"Resetting FIFO..."
           i2cWrite(MPU6050_ADDRESS, MPU_RA_USER_CTRL, 0x24);

           //"Rewriting I2C master mode enabled because...I don't know"
           i2cWrite(MPU6050_ADDRESS, MPU_RA_USER_CTRL, 0x20);

           //"Enabling and resetting DMP/FIFO..."
           i2cWrite(MPU6050_ADDRESS, MPU_RA_USER_CTRL, 0xE8);

           //writing final memory update 5/19 (function unknown)
           for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = mpu6050_dmpUpdates[pos];
           mpu6050_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);

           //writing final memory update 6/19 (function unknown)
           for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = mpu6050_dmpUpdates[pos];
           mpu6050_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);

           //writing final memory update 7/19 (function unknown)
           for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = mpu6050_dmpUpdates[pos];
           mpu6050_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);

           //writing final memory update 8/19 (function unknown)
           for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = mpu6050_dmpUpdates[pos];
           mpu6050_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);

           //writing final memory update 9/19 (function unknown)
           for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = mpu6050_dmpUpdates[pos];
           mpu6050_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);

           //writing final memory update 10/19 (function unknown)
           for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = mpu6050_dmpUpdates[pos];
           mpu6050_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);

           //writing final memory update 11/19 (function unknown)
           for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = mpu6050_dmpUpdates[pos];
           mpu6050_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);

           //reading final memory update 12/19 (function unknown)
           for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = mpu6050_dmpUpdates[pos];
           mpu6050_readMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);

           //writing final memory update 13/19 (function unknown)
           for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = mpu6050_dmpUpdates[pos];
           mpu6050_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);

           //writing final memory update 14/19 (function unknown)
           for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = mpu6050_dmpUpdates[pos];
           mpu6050_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);

           //writing final memory update 15/19 (function unknown)
           for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = mpu6050_dmpUpdates[pos];
           mpu6050_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);

           //writing final memory update 16/19 (function unknown)
           for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = mpu6050_dmpUpdates[pos];
           mpu6050_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);

           //writing final memory update 17/19 (function unknown)
           for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = mpu6050_dmpUpdates[pos];
           mpu6050_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);

            //waiting for FIFO count > =46
            while ((fifoCount = mpu6050_getFIFOCount()) < 46)
            	{
            	delay_ms(10);
            	fifoCount = 4;///////////////////////
            	}

            //reading FIFO data..."));
            mpu6050_getFIFOBytes(fifoBuffer, fifoCount < 128 ? fifoCount : 128);
            mpu6050_getIntStatus();

            //writing final memory update 18/19 (function unknown)
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = mpu6050_dmpUpdates[pos];
            mpu6050_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);

            //waiting for FIFO count > =48
            while ((fifoCount = mpu6050_getFIFOCount()) < 48);

            //reading FIFO data..."));
            mpu6050_getFIFOBytes(fifoBuffer, fifoCount < 128 ? fifoCount : 128);
            mpu6050_getIntStatus();

            //waiting for FIFO count > =48
            while ((fifoCount = mpu6050_getFIFOCount()) < 48);

            //reading FIFO data..."));
            mpu6050_getFIFOBytes(fifoBuffer, fifoCount < 128 ? fifoCount : 128);
            mpu6050_getIntStatus();


            //writing final memory update 19/19(function unknown)
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = mpu6050_dmpUpdates[pos];
            mpu6050_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);

            //disabling DMP (you turn it on later)
            mpu6050_dmpDisable();
            dmpPacketSize = 48;

            mpu6050_resetFIFO();
            mpu6050_getIntStatus();

        } else {
            return 2; // configuration block loading failed
        }
    } else {
        return 1; // main binary block loading failed
    }
    return 0; // success
}

uint8_t mpu6050_dmpInitialize6(void)
{
	mpu6050_reset();
	delay_ms(30);
    mpu6050_setSleepDisabled();

    mpu6050_setMemoryBank(0x10, 1, 1);
    mpu6050_setMemoryStartAddress(0x06);
    uint8_t hwRevision;
    i2cRead(MPU6050_ADDRESS, MPU_RA_MEM_R_W,1, &hwRevision);

    mpu6050_setMemoryBank(0, 0, 0);

    //get X/Y/Z gyro offsets
    int8_t xgOffset = mpu6050_getXGyroOffsetTC();
    int8_t ygOffset = mpu6050_getYGyroOffsetTC();
    int8_t zgOffset = mpu6050_getZGyroOffsetTC();

    //setting slave 0 address to 0x7F
	i2cWrite(MPU6050_ADDRESS, MPU_RA_I2C_SLV0_ADDR + 0*3, 0x7F);
//	//disabling I2C Master mode
	i2cWriteBit(MPU6050_ADDRESS, MPU_RA_USER_CTRL, 5, 0);
//	//setting slave 0 address to 0x68 (self)
	i2cWrite(MPU6050_ADDRESS, MPU_RA_I2C_SLV0_ADDR + 0*3, 0x68);
//	//resetting I2C Master control
	i2cWriteBit(MPU6050_ADDRESS, MPU_RA_USER_CTRL, 1, 1);
	delay_ms(20);

    //load DMP code into memory banks
    if (mpu6050_writeMemoryBlock(mpu6050_dmpMemory6, MPU6050_DMP_CODE_SIZE_6, 0, 0)) {
        if (mpu6050_writeDMPConfigurationSet(mpu6050_dmpConfig6, MPU6050_DMP_CONFIG_SIZE_6)) {

        	mpu6050_setClockSource(MPU6050_CLOCK_PLL_ZGYRO);

        	//set DMP and FIFO_OFLOW interrupts enabled
        	i2cWrite(MPU6050_ADDRESS, MPU_RA_INT_ENABLE, 0x12);

            //set sample rate
        	i2cWrite(MPU6050_ADDRESS, MPU_RA_SMPLRT_DIV, 4); // 1khz / (1 + 4) = 200 Hz

            //set external frame sync to TEMP_OUT_L[0]
        	i2cWriteBits(MPU6050_ADDRESS, MPU_RA_CONFIG, 5, 3, 0x1);

            //set DLPF bandwidth to 42Hz
        	i2cWriteBits(MPU6050_ADDRESS, MPU_RA_CONFIG, 2, 3, 0x03);

            //set gyro sensitivity to +/- 2000 deg/sec
        	i2cWriteBits(MPU6050_ADDRESS, MPU_RA_GYRO_CONFIG, 4, 2, 0x03);

            //set DMP configuration bytes (function unknown)
            i2cWrite(MPU6050_ADDRESS,MPU_RA_DMP_CFG_1, 0x03);
            i2cWrite(MPU6050_ADDRESS, MPU_RA_DMP_CFG_2, 0x00);

            //clear OTP Bank flag
            i2cWriteBit(MPU6050_ADDRESS, MPU_RA_XG_OFFS_TC, 0, 0);

            mpu6050_setXGyroOffsetTC(xgOffset);
            mpu6050_setYGyroOffsetTC(ygOffset);
            mpu6050_setZGyroOffsetTC(zgOffset);

            mpu6050_setXGyroOffset(0);
            mpu6050_setYGyroOffset(0);
            mpu6050_setZGyroOffset(0);

            //writing final memory update 1/7(function unknown)
            uint8_t dmpUpdate[16], j;
            uint16_t pos = 0;
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = mpu6050_dmpUpdates6[pos];
            mpu6050_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);

            //writing final memory update 2/7 (function unknown)
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = mpu6050_dmpUpdates6[pos];
            mpu6050_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);

            //reset FIFO
            mpu6050_resetFIFO();
            //i2cWriteBits(MPU6050_ADDRESS, MPU_RA_USER_CTRL, 2, 1, 1);

            //reading FIFO count
            uint8_t fifoCount = mpu6050_getFIFOCount();
            uint8_t fifoBuffer[128];
            mpu6050_getFIFOBytes(fifoBuffer, fifoCount);

            //setting motion detection threshold to 2
            i2cWrite(MPU6050_ADDRESS, MPU_RA_MOT_THR, 2);

            //setting zero-motion detection threshold to 156
            i2cWrite(MPU6050_ADDRESS, MPU_RA_ZRMOT_THR, 156);

            //setting motion detection duration to 80
            i2cWrite(MPU6050_ADDRESS, MPU_RA_MOT_DUR, 80);

            //setting zero-motion detection duration to 0
            i2cWrite(MPU6050_ADDRESS, MPU_RA_ZRMOT_DUR, 0);

            //reset FIFO
            mpu6050_resetFIFO();
//            i2cWriteBits(MPU6050_ADDRESS, MPU_RA_USER_CTRL, 2, 1, 1);

            //enabling FIFO
            i2cWriteBit(MPU6050_ADDRESS, MPU_RA_USER_CTRL, 6, 1);

            //enable dmp
            mpu6050_dmpEnable();
//            i2cWriteBit(MPU6050_ADDRESS, MPU_RA_USER_CTRL, 7, 1);

            //reset dmp
            i2cWriteBit(MPU6050_ADDRESS, MPU_RA_USER_CTRL, 3, 1);

           //writing final memory update 3/7 (function unknown)
           for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = mpu6050_dmpUpdates6[pos];
           mpu6050_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);

           //writing final memory update 4/7 (function unknown)
           for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = mpu6050_dmpUpdates6[pos];
           mpu6050_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);

           //writing final memory update 5/7 (function unknown)
           for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = mpu6050_dmpUpdates6[pos];
           mpu6050_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);

            //waiting for FIFO count > 3
            while ((fifoCount = mpu6050_getFIFOCount()) < 3);///////////////////////

            //reading FIFO data..."));
            mpu6050_getFIFOBytes(fifoBuffer, fifoCount);

            //writing final memory update 6/7 (function unknown)
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++) dmpUpdate[j] = mpu6050_dmpUpdates6[pos];
            mpu6050_readMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);

            //waiting for FIFO count > =3
            while ((fifoCount = mpu6050_getFIFOCount()) < 3);

            //reading FIFO data..."));
            mpu6050_getFIFOBytes(fifoBuffer, fifoCount);
            mpu6050_getIntStatus();     // TODO necessary?

            //writing final memory update 7/7 (function unknown)
            for (j = 0; j < 4 || j < dmpUpdate[2] + 3; j++, pos++)
            dmpUpdate[j] = mpu6050_dmpUpdates6[pos];
            mpu6050_writeMemoryBlock(dmpUpdate + 3, dmpUpdate[2], dmpUpdate[0], dmpUpdate[1]);

            dmpPacketSize = 42;
            //disabling DMP (you turn it on later)
            mpu6050_dmpDisable();

            mpu6050_resetFIFO();
            mpu6050_getIntStatus();
        } else {
            return 2; // configuration block loading failed
        }
    } else {
        return 1; // main binary block loading failed
    }
    return 0; // success
}

/*
 * enable dmp
 */
void mpu6050_dmpEnable(void) {
	//MPU6050_DMP_INT0ENABLE;
	i2cWriteBit(MPU6050_ADDRESS, MPU_RA_USER_CTRL, 7, 1);
}

/*
 * disable dmp
 */
void mpu6050_dmpDisable(void) {
//	MPU6050_DMP_INT0DISABLE;
	i2cWriteBit(MPU6050_ADDRESS, MPU_RA_USER_CTRL, 7, 0);
}

/*
 * get quaternion from packet
 */

void mpu6050_getQuaternion(const uint8_t* packet, quaternion *quat) {
	if (packet == 0) packet = dmpPacketBuffer;
    quat->qw = (float)((int16_t)(packet[0] << 8) + packet[1]) / 16384.0f;
    quat->qx = (float)((int16_t)(packet[4] << 8) + packet[5]) / 16384.0f;
    quat->qy = (float)((int16_t)(packet[8] << 8) + packet[9]) / 16384.0f;
    quat->qz = (float)((int16_t)(packet[12] << 8) + packet[13]) / 16384.0f;
}


void mpu6050_getMagDMP(const uint8_t* packet, axis *mag) {
	if (packet == 0) packet = dmpPacketBuffer;
    mag->x = ((int16_t)(packet[28] << 8) + packet[29]);
    mag->y = ((int16_t)(packet[30] << 8) + packet[31]);
    mag->z = ((int16_t)(packet[32] << 8) + packet[33]);
}

uint8_t mpu6050_getGravity(axis *gravity, quaternion *quat) {
	gravity->x = 2 * ((quat->qx)*(quat->qz) - (quat->qw)*(quat->qy));
	gravity->y = 2 * ((quat->qw)*(quat->qx) + (quat->qy)*(quat->qz));
	gravity->z = (quat->qw)*(quat->qw) - (quat->qx)*(quat->qx) - (quat->qy)*(quat->qy) + (quat->qz)*(quat->qz);
return 0;
}

/*
 * get euler angles
 * aerospace sequence, to obtain sensor attitude:
 * 1. rotate around sensor Z plane by yaw
 * 2. rotate around sensor Y plane by pitch
 * 3. rotate around sensor X plane by roll
 */
void mpu6050_getYawPitchRoll(quaternion *quat, angles *angle, axis *gravity) {
	angle->yaw =   atan2(2*(quat->qx)*(quat->qy) - 2*(quat->qw)*(quat->qz), 2*(quat->qw)*(quat->qw) + 2*(quat->qx)*(quat->qx) - 1); //positive values to the right
	angle->pitch = atan((gravity->x) / sqrt((gravity->y)*(gravity->y) + (gravity->z)*(gravity->z)));
	angle->roll =  -(atan((gravity->y) / sqrt((gravity->x)*(gravity->x) + (gravity->z)*(gravity->z)))); //negative values when left side is up
}

uint8_t mpu6050_getEuler(float *data, quaternion *quat) {
	data[0] = atan2(2*(quat->qx)*(quat->qy) - 2*(quat->qw)*(quat->qz), 2*(quat->qw)*(quat->qw) + 2*(quat->qx)*(quat->qx) - 1); // psi
	data[1] = -asin(2*(quat->qx)*(quat->qz) + 2*(quat->qw)*(quat->qy)); // theta
	data[2] = atan2(2*(quat->qy)*(quat->qz) - 2*(quat->qw)*(quat->qx), 2*(quat->qw)*(quat->qw) + 2*(quat->qz)*(quat->qz) - 1); // phi
return 0;
}

/*
 * set a chip memory bank
 */
void mpu6050_setMemoryBank(uint8_t bank, uint8_t prefetchEnabled, uint8_t userBank) {
    bank &= 0x1F;
    if (userBank) bank |= 0x20;
    if (prefetchEnabled) bank |= 0x40;
    i2cWrite(MPU6050_ADDRESS, MPU_RA_BANK_SEL, bank);
}

/*
 * set memory start address
 */
void mpu6050_setMemoryStartAddress(uint8_t address) {
	i2cWrite(MPU6050_ADDRESS, MPU_RA_MEM_START_ADDR, address);
}

/*
 * read a memory block
 */
void mpu6050_readMemoryBlock(uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address) {
	mpu6050_setMemoryBank(bank, 0, 0);
	mpu6050_setMemoryStartAddress(address);
    uint8_t chunkSize;
    for (uint16_t i = 0; i < dataSize;) {
        // determine correct chunk size according to bank position and data size
        chunkSize = MPU6050_DMP_MEMORY_CHUNK_SIZE;

        // make sure we don't go past the data size
        if (i + chunkSize > dataSize) chunkSize = dataSize - i;

        // make sure this chunk doesn't go past the bank boundary (256 bytes)
        if (chunkSize > 256 - address) chunkSize = 256 - address;

        // read the chunk of data as specified
        i2cRead(MPU6050_ADDRESS, MPU_RA_MEM_R_W, chunkSize, data + i);

        // increase byte index by [chunkSize]
        i += chunkSize;

        // uint8_t automatically wraps to 0 at 256
        address += chunkSize;

        // if we aren't done, update bank (if necessary) and address
        if (i < dataSize) {
            if (address == 0) bank++;
            mpu6050_setMemoryBank(bank, 0, 0);
            mpu6050_setMemoryStartAddress(address);
        }
    }
}

/*
 * write a memory block
 */
uint8_t mpu6050_writeMemoryBlock(const uint8_t *data, uint16_t dataSize, uint8_t bank, uint8_t address) {
	mpu6050_setMemoryBank(bank, 0, 0);
	mpu6050_setMemoryStartAddress(address);
    uint8_t chunkSize;
    uint8_t *progBuffer = 0;
    uint16_t i;
    for (i = 0; i < dataSize;) {
        // determine correct chunk size according to bank position and data size
        chunkSize = MPU6050_DMP_MEMORY_CHUNK_SIZE;

        // make sure we don't go past the data size
        if (i + chunkSize > dataSize) chunkSize = dataSize - i;

        // make sure this chunk doesn't go past the bank boundary (256 bytes)
        if (chunkSize > 256 - address) chunkSize = 256 - address;

        progBuffer = (uint8_t *)data + i;
        i2cWriteBuffer(MPU6050_ADDRESS, MPU_RA_MEM_R_W, chunkSize, progBuffer);

        // increase byte index by [chunkSize]
        i += chunkSize;
        // uint8_t automatically wraps to 0 at 256
        address += chunkSize;
        // if we aren't done, update bank (if necessary) and address
        if (i < dataSize)
        {
            if (address == 0) bank++;
            mpu6050_setMemoryBank(bank, 0, 0);
            mpu6050_setMemoryStartAddress(address);
        }
    }

    return 1;
}

/*
 * write a dmp configuration set
 */
uint8_t mpu6050_writeDMPConfigurationSet(const uint8_t *data, uint16_t dataSize) {
    uint8_t *progBuffer = 0;
    uint8_t special;
    uint16_t i;

    // config set data is a long string of blocks with the following structure:
    // [bank] [offset] [length] [byte[0], byte[1], ..., byte[length]]
    uint8_t bank, offset, length;
    for (i = 0; i < dataSize;) {
            bank = data[i++];
            offset = data[i++];
            length = data[i++];

        // write data or perform special action
        if (length > 0)
        {
            progBuffer = (uint8_t *)data + i;
            mpu6050_writeMemoryBlock(progBuffer, length, bank, offset);
            i += length;
        } else {
				special = data[i++];
				if (special == 0x01)
				{
					i2cWrite(MPU6050_ADDRESS, MPU_RA_INT_ENABLE, 0x32);  // single operation
				}
			}
    }
    return 1;
}

/*
 * get the fifo count
 */
uint16_t mpu6050_getFIFOCount(void) {
	i2cRead(MPU6050_ADDRESS,MPU_RA_FIFO_COUNTH, 2, (uint8_t *)buffer);
    return (((uint16_t)buffer[0]) << 8) | buffer[1];
}

/*
 * read fifo bytes
 */
void mpu6050_getFIFOBytes(uint8_t *data, uint8_t length) {
	i2cRead(MPU6050_ADDRESS, MPU_RA_FIFO_R_W, length, data);
}

/*
 * get the interrupt status
 */
uint8_t mpu6050_getIntStatus(void) {
	i2cRead(MPU6050_ADDRESS, MPU_RA_INT_STATUS,1, (uint8_t *)buffer);
    return buffer[0];
}

/*
 * reset fifo
 */
void mpu6050_resetFIFO(void) {
	i2cWriteBit(MPU6050_ADDRESS, MPU_RA_USER_CTRL, 2, 1);
}

/*
 * get gyro offset X
 */
int8_t mpu6050_getXGyroOffsetTC(void) {
	i2cReadBits(MPU6050_ADDRESS, MPU_RA_XG_OFFS_TC, 6, 6, buffer);
    return buffer[0];
}

/*
 * set gyro offset X
 */
void mpu6050_setXGyroOffsetTC(int8_t offset) {
	i2cWriteBits(MPU6050_ADDRESS, MPU_RA_XG_OFFS_TC, 6, 6, offset);
}

/*
 * get gyro offset Y
 */
int8_t mpu6050_getYGyroOffsetTC(void) {
	i2cReadBits(MPU6050_ADDRESS,MPU_RA_YG_OFFS_TC, 6, 6, buffer);
    return buffer[0];
}

/*
 * set gyro offset Y
 */
void mpu6050_setYGyroOffsetTC(int8_t offset) {
	i2cWriteBits(MPU6050_ADDRESS, MPU_RA_YG_OFFS_TC, 6, 6, offset);
}

/*
 * get gyro offset Z
 */
int8_t mpu6050_getZGyroOffsetTC(void) {
	i2cReadBits(MPU6050_ADDRESS,MPU_RA_ZG_OFFS_TC, 6, 6, buffer);
    return buffer[0];
}

/*
 * set gyro offset Z
 */
void mpu6050_setZGyroOffsetTC(int8_t offset) {
	i2cWriteBits(MPU6050_ADDRESS, MPU_RA_ZG_OFFS_TC, 6, 6, offset);
}

// XA_OFFS_* registers
int16_t mpu6050_getXAccelOffset(void) {
	i2cRead(MPU6050_ADDRESS, MPU_RA_XA_OFFS_H, 2, buffer);
	return (((int16_t)buffer[0]) << 8) | buffer[1];
}

void mpu6050_setXAccelOffset(int16_t offset) {
	uint8_t MSB=(uint8_t)(offset >> 8);
	uint8_t LSB=(uint8_t)offset;
	i2cWrite(MPU6050_ADDRESS, MPU_RA_XA_OFFS_H, MSB);
	i2cWrite(MPU6050_ADDRESS, MPU_RA_XA_OFFS_L_TC, LSB);
}

// YA_OFFS_* register
int16_t mpu6050_getYAccelOffset(void) {
	i2cRead(MPU6050_ADDRESS, MPU_RA_YA_OFFS_H, 2, buffer);
	return (((int16_t)buffer[0]) << 8) | buffer[1];
}

void mpu6050_setYAccelOffset(int16_t offset) {
	uint8_t MSB=(uint8_t)(offset >> 8);
	uint8_t LSB=(uint8_t)offset;
	i2cWrite(MPU6050_ADDRESS, MPU_RA_YA_OFFS_H, MSB);
	i2cWrite(MPU6050_ADDRESS, MPU_RA_YA_OFFS_L_TC, LSB);
}

// ZA_OFFS_* register
int16_t mpu6050_getZAccelOffset(void) {
	i2cRead(MPU6050_ADDRESS, MPU_RA_ZA_OFFS_H, 2, buffer);
	return (((int16_t)buffer[0]) << 8) | buffer[1];
}

void mpu6050_setZAccelOffset(int16_t offset) {
	uint8_t MSB=(uint8_t)(offset >> 8);
	uint8_t LSB=(uint8_t)offset;
	i2cWrite(MPU6050_ADDRESS, MPU_RA_ZA_OFFS_H, MSB);
	i2cWrite(MPU6050_ADDRESS, MPU_RA_ZA_OFFS_L_TC, LSB);
}


// XG_OFFS_USR* registers
int16_t mpu6050_getXGyroOffset(void) {
	i2cRead(MPU6050_ADDRESS, MPU_RA_XG_OFFS_USRH, 2, buffer);
	return (((int16_t)buffer[0]) << 8) | buffer[1];
}

void mpu6050_setXGyroOffset(int16_t offset) {
	uint8_t MSB=(uint8_t)(offset >> 8);
	uint8_t LSB=(uint8_t)offset;
	i2cWrite(MPU6050_ADDRESS, MPU_RA_XG_OFFS_USRH, MSB);
	i2cWrite(MPU6050_ADDRESS, MPU_RA_XG_OFFS_USRL, LSB);
}
// YG_OFFS_USR* register
int16_t mpu6050_getYGyroOffset(void) {
	i2cRead(MPU6050_ADDRESS, MPU_RA_YG_OFFS_USRH, 2, buffer);
	return (((int16_t)buffer[0]) << 8) | buffer[1];
}

void mpu6050_setYGyroOffset(int16_t offset) {
	uint8_t MSB=(uint8_t)(offset >> 8);
	uint8_t LSB=(uint8_t)offset;
	i2cWrite(MPU6050_ADDRESS, MPU_RA_YG_OFFS_USRH, MSB);
	i2cWrite(MPU6050_ADDRESS, MPU_RA_YG_OFFS_USRL, LSB);
}

// ZG_OFFS_USR* register
int16_t mpu6050_getZGyroOffset(void) {
	i2cRead(MPU6050_ADDRESS, MPU_RA_ZG_OFFS_USRH, 2, buffer);
	return (((int16_t)buffer[0]) << 8) | buffer[1];
}

void mpu6050_setZGyroOffset(int16_t offset) {
	uint8_t MSB=(uint8_t)(offset >> 8);
	uint8_t LSB=(uint8_t)offset;
	i2cWrite(MPU6050_ADDRESS, MPU_RA_ZG_OFFS_USRH, MSB);
	i2cWrite(MPU6050_ADDRESS, MPU_RA_ZG_OFFS_USRL, LSB);
}


/*
 * set sleep disabled
 */
void mpu6050_setSleepDisabled(void) {
	i2cWriteBit(MPU6050_ADDRESS, MPU_RA_PWR_MGMT_1, 6, 0);
}

/*
 * set sleep enabled
 */
void mpu6050_setSleepEnabled(void) {
	i2cWriteBit(MPU6050_ADDRESS, MPU_RA_PWR_MGMT_1, 6, 1);
}

//set clock source
void mpu6050_setClockSource(uint8_t source) {
	i2cWriteBits(MPU6050_ADDRESS, MPU_RA_PWR_MGMT_1, 2, 3, source);
}

void mpu6050_reset(void) {
	i2cWriteBit(MPU6050_ADDRESS, MPU_RA_PWR_MGMT_1, 7, 1);
}

/** Set I2C Master Mode enabled status.
* @param enabled New I2C Master Mode enabled status
* @see getI2CMasterModeEnabled()
* @see MPU6050_RA_USER_CTRL
* @see MPU6050_USERCTRL_I2C_MST_EN_BIT
*/
void mpu6050_setI2CMasterModeEnabled(bool enabled) {
	i2cWriteBit(MPU6050_ADDRESS, MPU_RA_USER_CTRL, 5, enabled);
}

/** Set I2C bypass enabled status.
* When this bit is equal to 1 and I2C_MST_EN (Register 106 bit[5]) is equal to
* 0, the host application processor will be able to directly access the
* auxiliary I2C bus of the MPU-60X0. When this bit is equal to 0, the host
* application processor will not be able to directly access the auxiliary I2C
* bus of the MPU-60X0 regardless of the state of I2C_MST_EN (Register 106
* bit[5]).
* @param enabled New I2C bypass enabled status
* @see MPU6050_RA_INT_PIN_CFG
* @see MPU6050_INTCFG_I2C_BYPASS_EN_BIT
*/
void mpu6050_setI2CBypassEnabled(bool enabled) {
	i2cWriteBit(MPU6050_ADDRESS, MPU_RA_INT_PIN_CFG, 1, enabled);
}


/** Set the I2C address of the specified slave (0-3).
* @param num Slave number (0-3)
* @param address New address for specified slave
* @see getSlaveAddress()
* @see MPU6050_RA_I2C_SLV0_ADDR
*/
void mpu6050_setSlaveAddress(uint8_t num, uint8_t address) {
	if (num > 3) return;
	i2cWrite(MPU6050_ADDRESS, MPU_RA_I2C_SLV0_ADDR + num*3, address);
}


/** Set the active internal register for the specified slave (0-3).
* @param num Slave number (0-3)
* @param reg New active register for specified slave
* @see getSlaveRegister()
* @see MPU6050_RA_I2C_SLV0_REG
*/
void mpu6050_setSlaveRegister(uint8_t num, uint8_t reg) {
	if (num > 3) return;
	i2cWrite(MPU6050_ADDRESS, MPU_RA_I2C_SLV0_REG + num*3, reg);
}



void mpu6050_setSlaveControl(uint8_t num, uint8_t enabled, bool word_byte_swap, bool write_mode, bool group_offset, uint8_t length)
{
	mpu6050_setSlaveEnabled(num, enabled);
	mpu6050_setSlaveWordByteSwap(num, word_byte_swap);
	mpu6050_setSlaveWriteMode(num, write_mode);
	mpu6050_setSlaveWordGroupOffset(num, group_offset);
	mpu6050_setSlaveDataLength(num, length);
}
// num, slave_enabled, word_byte_swap, write_mode, group_offset, data_length
    // implemented prev method to set whole SLV*_CTRL reg at once.


/** Get the active internal register for the specified slave (0-3).
* Read/write operations for this slave will be done to whatever internal
* register address is stored in this MPU register.
*
* The MPU-6050 supports a total of five slaves, but Slave 4 has unique
* characteristics, and so it has its own functions.
*
* @param num Slave number (0-3)
* @return Current active register for specified slave
* @see MPU6050_RA_I2C_SLV0_REG
*/
uint8_t mpu6050_getSlaveRegister(uint8_t num) {
	if (num > 3) return 0;
	i2cRead(MPU6050_ADDRESS, MPU_RA_I2C_SLV0_REG + num*3,1,  buffer);
	return buffer[0];
}

/** Get the enabled value for the specified slave (0-3).
* When set to 1, this bit enables Slave 0 for data transfer operations. When
* cleared to 0, this bit disables Slave 0 from data transfer operations.
* @param num Slave number (0-3)
* @return Current enabled value for specified slave
* @see MPU6050_RA_I2C_SLV0_CTRL
*/
bool mpu6050_getSlaveEnabled(uint8_t num) {
	if (num > 3) return 0;
	i2cReadBit(MPU6050_ADDRESS, MPU_RA_I2C_SLV0_CTRL + num*3, MPU_I2C_SLV_EN_BIT, buffer);
	return buffer[0];
}

/** Set the enabled value for the specified slave (0-3).
* @param num Slave number (0-3)
* @param enabled New enabled value for specified slave
* @see getSlaveEnabled()
* @see MPU6050_RA_I2C_SLV0_CTRL
*/
void mpu6050_setSlaveEnabled(uint8_t num, bool enabled) {
	if (num > 3) return;
	i2cWriteBit(MPU6050_ADDRESS, MPU_RA_I2C_SLV0_CTRL + num*3, MPU_I2C_SLV_EN_BIT, enabled);
}

/** Get word pair byte-swapping enabled for the specified slave (0-3).
* When set to 1, this bit enables byte swapping. When byte swapping is enabled,
* the high and low bytes of a word pair are swapped. Please refer to
* I2C_SLV0_GRP for the pairing convention of the word pairs. When cleared to 0,
* bytes transferred to and from Slave 0 will be written to EXT_SENS_DATA
* registers in the order they were transferred.
*
* @param num Slave number (0-3)
* @return Current word pair byte-swapping enabled value for specified slave
* @see MPU6050_RA_I2C_SLV0_CTRL
*/
bool mpu6050_getSlaveWordByteSwap(uint8_t num) {
	if (num > 3) return 0;
	i2cReadBit(MPU6050_ADDRESS, MPU_RA_I2C_SLV0_CTRL + num*3, MPU_I2C_SLV_BYTE_SW_BIT, buffer);
	return buffer[0];
}

/** Set word pair byte-swapping enabled for the specified slave (0-3).
* @param num Slave number (0-3)
* @param enabled New word pair byte-swapping enabled value for specified slave
* @see getSlaveWordByteSwap()
* @see MPU6050_RA_I2C_SLV0_CTRL
*/
void mpu6050_setSlaveWordByteSwap(uint8_t num, bool enabled) {
	if (num > 3) return;
	i2cWriteBit(MPU6050_ADDRESS, MPU_RA_I2C_SLV0_CTRL + num*3, MPU_I2C_SLV_BYTE_SW_BIT, enabled);
}

/** Get write mode for the specified slave (0-3).
* When set to 1, the transaction will read or write data only. When cleared to
* 0, the transaction will write a register address prior to reading or writing
* data. This should equal 0 when specifying the register address within the
* Slave device to/from which the ensuing data transaction will take place.
*
* @param num Slave number (0-3)
* @return Current write mode for specified slave (0 = register address + data, 1 = data only)
* @see MPU6050_RA_I2C_SLV0_CTRL
*/
bool mpu6050_getSlaveWriteMode(uint8_t num) {
	if (num > 3) return 0;
	i2cReadBit(MPU6050_ADDRESS, MPU_RA_I2C_SLV0_CTRL + num*3, MPU_I2C_SLV_REG_DIS_BIT, buffer);
	return buffer[0];
}

/** Set write mode for the specified slave (0-3).
* @param num Slave number (0-3)
* @param mode New write mode for specified slave (0 = register address + data, 1 = data only)
* @see getSlaveWriteMode()
* @see MPU6050_RA_I2C_SLV0_CTRL
*/
void mpu6050_setSlaveWriteMode(uint8_t num, bool mode) {
	if (num > 3) return;
	i2cWriteBit(MPU6050_ADDRESS, MPU_RA_I2C_SLV0_CTRL + num*3, MPU_I2C_SLV_REG_DIS_BIT, mode);
}

/** Get word pair grouping order offset for the specified slave (0-3).
* This sets specifies the grouping order of word pairs received from registers.
* When cleared to 0, bytes from register addresses 0 and 1, 2 and 3, etc (even,
* then odd register addresses) are paired to form a word. When set to 1, bytes
* from register addresses are paired 1 and 2, 3 and 4, etc. (odd, then even
* register addresses) are paired to form a word.
*
* @param num Slave number (0-3)
* @return Current word pair grouping order offset for specified slave
* @see MPU6050_RA_I2C_SLV0_CTRL
*/
bool mpu6050_getSlaveWordGroupOffset(uint8_t num) {
	if (num > 3) return 0;
	i2cReadBit(MPU6050_ADDRESS, MPU_RA_I2C_SLV0_CTRL + num*3, MPU_I2C_SLV_GRP_BIT, buffer);
	return buffer[0];
}

/** Set word pair grouping order offset for the specified slave (0-3).
* @param num Slave number (0-3)
* @param enabled New word pair grouping order offset for specified slave
* @see getSlaveWordGroupOffset()
* @see MPU6050_RA_I2C_SLV0_CTRL
*/
void mpu6050_setSlaveWordGroupOffset(uint8_t num, bool enabled) {
	if (num > 3) return;
	i2cWriteBit(MPU6050_ADDRESS, MPU_RA_I2C_SLV0_CTRL + num*3, MPU_I2C_SLV_GRP_BIT, enabled);
}

/** Get number of bytes to read for the specified slave (0-3).
* Specifies the number of bytes transferred to and from Slave 0. Clearing this
* bit to 0 is equivalent to disabling the register by writing 0 to I2C_SLV0_EN.
* @param num Slave number (0-3)
* @return Number of bytes to read for specified slave
* @see MPU6050_RA_I2C_SLV0_CTRL
*/
uint8_t mpu6050_getSlaveDataLength(uint8_t num) {
	if (num > 3) return 0;
	i2cReadBits(MPU6050_ADDRESS, MPU_RA_I2C_SLV0_CTRL + num*3, MPU_I2C_SLV_LEN_BIT, MPU_I2C_SLV_LEN_LENGTH, buffer);
	return buffer[0];
}

/** Set number of bytes to read for the specified slave (0-3).
* @param num Slave number (0-3)
* @param length Number of bytes to read for specified slave
* @see getSlaveDataLength()
* @see MPU6050_RA_I2C_SLV0_CTRL
*/
void mpu6050_setSlaveDataLength(uint8_t num, uint8_t length) {
	if (num > 3) return;
	i2cWriteBits(MPU6050_ADDRESS, MPU_RA_I2C_SLV0_CTRL + num*3, MPU_I2C_SLV_LEN_BIT, MPU_I2C_SLV_LEN_LENGTH, length);
}

long map(long x, long in_min, long in_max, long out_min, long out_max){
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

int imu_init(void){
	uint8_t devStatus;
	bool detected;
	mpu6050_reset();  //
	detected=sensorsAutodetect();

	//devStatus=mpu6050_dmpInitialize();
	if (detected)
	{
		//vTaskSuspendAll();
		devStatus=mpu6050_dmpInitialize();
		//xTaskResumeAll();

		if (devStatus == 0)
		{
			 GPIO_SetBits(GPIOA, GPIO_Pin_5);
			mpu6050_dmpEnable(); //enable in the reading task?
		}

	}

	  //FreeRTOS
//	  	imu_queue = xQueueCreate(IMU_QUEUE_SIZE, sizeof(angles));
//	    if(imu_queue == 0)
//	        return pdFALSE;

	 	 imu_data_rdy = xSemaphoreCreateBinary();
	 	 if(imu_data_rdy == NULL)
	 		 return pdFALSE;

	 	 imu_data_update = xSemaphoreCreateMutex();
	 	 if(imu_data_update == NULL)
	 		 return pdFALSE;

	   portBASE_TYPE ret = xTaskCreate(imu_task, NULL, 256, NULL, 2, NULL);
	    if(ret != pdPASS)
	        return pdFALSE;


	    return pdTRUE;
}

static void imu_task(void *parameters){
		uint8_t mpuIntStatus; // holds actual interrupt status byte from MPU
		uint16_t fifoCount;
		uint8_t fifoBuffer[48]; //64 - 6 dof// FIFO storage buffer

		quaternion quat;
		axis gravity;

		while(1){
			GPIO_ToggleBits(GPIOA, GPIO_Pin_7);
			mpuIntStatus =  mpu6050_getIntStatus();
			// get current FIFO count

			if(!(mpuIntStatus & 0x09)){
				//GPIO_ToggleBits(GPIOA, GPIO_Pin_5);
			//	serial_puts("no int\r\n");
				continue;
			}

			fifoCount = mpu6050_getFIFOCount();
			// check for overflow (this should never happen unless our code is too inefficient)
			if ((mpuIntStatus & 0x10) || fifoCount == 1024) {
			// reset so we can continue cleanly
				mpu6050_resetFIFO();
				serial_puts("FIFO overflow!\r\n");
			// otherwise, check for DMP data ready interrupt (this should happen frequently)
			} else if (mpuIntStatus & 0x03) {
				// wait for correct available data length, should be a VERY short wait
				//while (fifoCount < dmpPacketSize) fifoCount = mpu6050_getFIFOCount();
				if(fifoCount<dmpPacketSize){
					//GPIO_ToggleBits(GPIOA, GPIO_Pin_5);
				//	serial_puts("fifocount < packet\r\n");
					continue;
				}
				// read a packet from FIFO
			 	mpu6050_getFIFOBytes(fifoBuffer, dmpPacketSize);
//
//			 	 int16_t a = (fifoBuffer[0] << 8) + fifoBuffer[1];
//			 	 int16_t b = (fifoBuffer[4] << 8) + fifoBuffer[5];
//			 	 int16_t c = (fifoBuffer[8] << 8) + fifoBuffer[9];
//			 	 int16_t d = (fifoBuffer[12] << 8) + fifoBuffer[13];
//
//			 	sprintf(buf, "%x %x %x %x\r\n", a, b, c, d);
//			 	serial_puts(buf);


				GPIO_ToggleBits(GPIOA, GPIO_Pin_7);
				// track FIFO count here in case there is > 1 packet available
				// (this lets us immediately read more without waiting for an interrupt)
				fifoCount -= dmpPacketSize;


//
//				sprintf(buf, "%d %d %d\r\n", (int16_t)((fifoBuffer[0] << 8) + fifoBuffer[1]),
//						(int16_t)((fifoBuffer[4] << 8) + fifoBuffer[5]),
//						(int16_t)((fifoBuffer[8] << 8) + fifoBuffer[9]));
//				serial_puts(buf);
#if 1
				//if(++cnt % 10 == 0)
				{
					mpu6050_getQuaternion(fifoBuffer, &quat);
					mpu6050_getGravity(&gravity, &quat);
					if(xSemaphoreTake(imu_data_update, 50 / portTICK_PERIOD_MS))
					{
						mpu6050_getYawPitchRoll(&quat, &imu_position, &gravity);
						xSemaphoreGive(imu_data_update);
						xSemaphoreGive(imu_data_rdy);
					}


//					int_yaw=(current_position.yaw*1000*180.0f/M_PI);
//					int_pitch=(current_position.pitch*1000*180.0f/M_PI);
//					int_roll=(current_position.roll*1000*180.0f/M_PI);
//
//
//					sprintf(buf, "%d.%03d,", int_yaw / 1000, abs(int_yaw) % 1000);
//					serial_puts(buf);
//					sprintf(buf, "%d.%03d,", int_pitch / 1000, abs(int_pitch) % 1000);
//					serial_puts(buf);
//					sprintf(buf, "%d.%03d\r\n", int_roll/ 1000, abs(int_roll) % 1000);
//					serial_puts(buf);
				}
					//xQueueSend( imu_queue, ( void * ) &CurrentPosition, 0); // if full don't wait? or overwrite?

#endif
			}
		}
}
